<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.59.1 with theme Tranquilpeak 0.4.7-BETA">
<meta name="author" content="Steve Zhou">
<meta name="keywords" content="">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="LC 10/44/72/139/1223 - DFS with Memorization">
<meta name="twitter:title" content="LC 10/44/72/139/1223 - DFS with Memorization">
<meta property="og:url" content="https://yyzhou95.github.io/2019/10/lc-10/44/72/139/1223-dfs-with-memorization/">
<meta property="twitter:url" content="https://yyzhou95.github.io/2019/10/lc-10/44/72/139/1223-dfs-with-memorization/">
<meta property="og:site_name" content="Bingo!">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2019-10-14T00:00:00">
  
  
    <meta property="article:modified_time" content="2019-10-14T00:00:00">
  
  
  
    
      <meta property="article:section" content="Algorithm">
    
  
  
    
      <meta property="article:tag" content="Dynamic Programming">
    
      <meta property="article:tag" content="DFS">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://yyzhou95.github.io/img/avatar.jpg">
  <meta property="twitter:image" content="https://yyzhou95.github.io/img/avatar.jpg">


    <title>LC 10/44/72/139/1223 - DFS with Memorization</title>

    <link rel="icon" href="https://yyzhou95.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://yyzhou95.github.io/2019/10/lc-10/44/72/139/1223-dfs-with-memorization/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://yyzhou95.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://yyzhou95.github.io/css/about.css">
      
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://yyzhou95.github.io/">Bingo!</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://yyzhou95.github.io/about">
    
    
    
      
        <img class="header-picture" src="https://yyzhou95.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://yyzhou95.github.io/about">
          <img class="sidebar-profile-picture" src="https://yyzhou95.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Steve Zhou</h4>
        
          <h5 class="sidebar-profile-bio">Bingo!</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/categories/algorithm/">
    
      <i class="sidebar-button-icon fa fa-lg fa-flag-o"></i>
      
      <span class="sidebar-button-desc">Algorithm</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/categories/notes/">
    
      <i class="sidebar-button-icon fa fa-lg fa-sticky-note"></i>
      
      <span class="sidebar-button-desc">Notebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/yyzhou95" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/yyzhou95/yyzhou95.github.io" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-link"></i>
      
      <span class="sidebar-button-desc">Source Code</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaOut
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      LC 10/44/72/139/1223 - DFS with Memorization
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-10-14T00:00:00Z">
        
  October 14, 2019

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://yyzhou95.github.io/categories/algorithm">Algorithm</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <h1 id="table-of-contents">Table of Contents</h1><nav id="TableOfContents">
<ul>
<li><a href="#regular-expression-matching">Regular Expression Matching</a>
<ul>
<li><a href="#problem-description">Problem description</a></li>
<li><a href="#method">Method</a></li>
<li><a href="#code">Code</a></li>
</ul></li>
<li><a href="#wildcard-matching">Wildcard Matching</a>
<ul>
<li><a href="#problem-description-1">Problem description</a></li>
<li><a href="#method-1">Method</a></li>
<li><a href="#code-1">Code</a></li>
</ul></li>
<li><a href="#edit-distance">Edit Distance</a>
<ul>
<li><a href="#problem-description-2">Problem description</a></li>
<li><a href="#method-2">Method</a></li>
<li><a href="#code-2">Code</a></li>
</ul></li>
<li><a href="#word-break">Word Break</a>
<ul>
<li><a href="#problem-description-3">Problem description</a></li>
<li><a href="#method-3">Method</a></li>
<li><a href="#code-3">Code</a></li>
</ul></li>
<li><a href="#dice-roll-simulation">Dice Roll Simulation</a>
<ul>
<li><a href="#problem-description-4">Problem description</a></li>
<li><a href="#method-4">Method</a></li>
<li><a href="#code-4">Code</a></li>
</ul></li>
</ul>
</nav>

<h1 id="regular-expression-matching">Regular Expression Matching</h1>

<p>Link: <a href="https://leetcode.com/problems/regular-expression-matching">Regular Expression Matching</a></p>

<h2 id="problem-description">Problem description</h2>

<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>'.'</code> and <code>'*'</code>.</p>

<pre><code>'.' Matches any single character.
'*' Matches zero or more of the preceding element.
</code></pre>

<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>

<p><strong>Note:</strong></p>

<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>
</ul>

<p><strong>Example 1:</strong></p>

<pre><code>Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes &quot;aa&quot;.
</code></pre>

<p><strong>Example 3:</strong></p>

<pre><code>Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
</code></pre>

<p><strong>Example 4:</strong></p>

<pre><code>Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.
</code></pre>

<p><strong>Example 5:</strong></p>

<pre><code>Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
</code></pre>

<h2 id="method">Method</h2>

<p>Dynamic programming with 2D table.</p>

<p>There are several conditions for state transition, assuming column of boolean table representing pattern string.</p>

<p>Note that boolean table has one more row and column than string, hence, if using table index in iteration, corresponding string index should be <code>index - 1</code>.</p>

<ul>
<li>First of all, iterate the first row of table, and if <code>*</code>is met, fill <code>dp[0][i]</code> with value in <code>dp[0][i]</code>. This is for the case of pattern starts with <code>.*</code>.</li>
<li>Then iterating table start from second row and column. If current char in string and pattern is not matched and none of them are <code>.</code> or <code>*</code>, leave it.</li>
<li>If current char in pattern is <code>.</code>, then it matches with any char in <code>s</code>. The current char is matched depends on <code>s</code> and <code>p</code> that removing these matched char, which is <code>dp[i - 1][j - 1]</code>. The same situation happens when pattern and string has same char.</li>
<li>If current char in pattern is <code>*</code>, then there are two conditions. First, if <code>p.charAt(j - 2) != s.charAt(i) &amp;&amp; p.charAt(j - 2) != '.'</code>, then it means this <code>*</code> can only match previous pattern in 0 time, since previous char in pattern is not match to the char in string. The second condition is the rest situations. In this situation it means char before <code>*</code> can match more than one time. The <code>.</code> has same function as two same char.</li>
<li>Finally, return <code>dp[s.length()][p.length()]</code>.</li>
</ul>

<p>This problem can also be solved by DFS. The branch of DFS is as following:</p>

<ol>
<li>If <code>*</code> is the second char in pattern (<code>n == i - 2</code> ) to match if <code>*</code> is the second char in pattern.</li>
<li>If <code>*</code> matches 0 times in <code>s</code>.</li>
</ol>

<p>The above two conditions requires to move <code>i</code> backward one and <code>j</code> move forward 1.</p>

<ol>
<li><code>s.charAt(i) == p.charAt(j)</code> or <code>p.charAt(j) == ‘.’</code>.</li>
<li><code>j + 1 &lt; p.length() &amp;&amp; p.charAt(j + 1) == '*’</code> to match previous char more than 1 time.</li>
</ol>

<p>The above conditions can only move <code>i</code> and <code>j</code> forward. See code below.</p>

<h2 id="code">Code</h2>

<pre><code class="language-java">/**
 * Dynamic programming with 2D table.
 * Each time, find current matched string and pattern. Check if string matches pattern before current matched part.
 * State transition:
 * If (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.') -&gt;  dp[i + 1][j + 1] = dp[i][j]
 * If (p.charAt(j) == '*'):
 * 1. p(j - 2) could only be matched for 0 time.
 * 2. Match p(j - 2) for 1 time.
 * 3. Match p(j - 1) for n times.
 * 4. Match p in format as &quot;.*&quot; 0 ~ n times.
 * If no condition satisfied, return false.
 *
 * @param s string
 * @param p pattern string
 * @return if string is matched to pattern
 */
public boolean isMatch(String s, String p) {

    /* Corner case */
    if (s == null || p == null) {
        return false;
    }

    int l1 = s.length();
    int l2 = p.length();

    boolean[][] dp = new boolean[l1 + 1][l2 + 1];
    dp[0][0] = true;
    for (int i = 1; i &lt;= l2; i++) {
        if (p.charAt(i - 1) == '*') {
            dp[0][i] = dp[0][i - 2];        // for the case of pattern starts with .*
        }
    }

    for (int i = 1; i &lt;= l1; i++) {
        for (int j = 1; j &lt;= l2; j++) {

            /*
             * If current char matches, or pattern is '.', then dp[i][j] = dp[i - 1][j - 1].
             * Both pattern char and string char is matched, check string and pattern before matched. */
            if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            }

            /*
             * If p.charAt(j - 1) == '*', then matched pattern will be:
             * 1. p(j - 2) could only be matched for 0 time.
             * 2. Match p(j - 2) for 1 time.
             * 3. Match p(j - 1) for n times.
             * 4. Match p in format as &quot;.*&quot; 0 ~ n times. */
            if (p.charAt(j - 1) == '*') {

                /*
                 * If s(i - 1) != p(j - 2) &amp;&amp; p(j - 2) != '.', then no match found in p.
                 * p(j - 2) could only be matched for 0 time.
                 * Check if string matches pattern before '*' and its previous char. */
                if (s.charAt(i - 1) != p.charAt(j - 2) &amp;&amp; p.charAt(j - 2) != '.') {
                    dp[i][j] = dp[i][j - 2];
                } else {

                    /*
                     * Otherwise, there are three conditions:
                     * 1. Match p(j - 2) for 1 time: dp[i][j - 1]
                     * 2. Match p(j - 1) for n times: dp[i - 1][j] (this is actually only matched in s, not in p)
                     * 3. Match p in format as &quot;.*&quot; 0 ~ n times: dp[i][j - 2] || dp[i][j - 1] || dp[i - 1][j] */
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j] || dp[i][j - 2];
                }
            }
        }
    }

    return dp[l1][l2];
}

/**
 * Use DFS searching to find if s is matched to p.
 * During the searching process, use a 2D int array to record previous result as pruning.
 *
 * @param s string
 * @param p pattern string
 * @return if string is matched to pattern
 */
public boolean dfsImpl(String s, String p) {

    /* Corner case */
    if (p == null || s == null) {
        return false;
    }

    int[][] mem = new int[s.length() + 1][p.length() + 1];

    for (int i = p.length(); i &gt;= 0 &amp;&amp; (i == p.length() || (i &lt; p.length() &amp;&amp; p.charAt(i + 1) == '*')); i -= 2) {
        mem[s.length()][i] = 1;
    }

    return dfs(s, p, 0, 0, mem);
}

/**
 * DFS searching with a 2D int table to accomplish pruning (can be done by hash map).
 *
 * @param s   string
 * @param p   pattern string
 * @param i   current index of string
 * @param j   current index of pattern
 * @param mem 2D boolean array to store the previous result
 * @return if string is matched to pattern
 */
private boolean dfs(String s, String p, int i, int j, int[][] mem) {

    if (mem[i][j] != 0) {      // reuse previous result
        return mem[i][j] == 1;
    }

    if (j &gt;= p.length()) {      // avoid overflow
        return false;
    }

    if (p.charAt(j) == '*') {
        int n = i - 2;

        /*
         * n - 2: char in pattern before * and one char ahead. This is to handle the case where * matches 0 times.
         * 1. If '*' is the second char in pattern: n == i - 2
         * 2. If '*' matches 0 times in s
         * If char before '*' is '.', then it can match for any char for any times: p.charAt(j - 1) == '.' */
        while (n &lt; s.length() &amp;&amp; (n == i - 2 || s.charAt(n) == p.charAt(j - 1) || p.charAt(j - 1) == '.')) {
            if (dfs(s, p, ++n, j + 1, mem)) {
                mem[i][j] = 1;
                return true;
            }
        }
    } else if (i &lt; s.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')) {
        mem[i][j] = dfs(s, p, i + 1, j + 1, mem) ? 1 : -1;
        return mem[i][j] == 1;
    } else if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j + 1) == '*') {      // match previous char more than 1 time
        mem[i][j] = dfs(s, p, i, j + 2, mem) ? 1 : -1;
        return mem[i][j] == 1;
    }

    return false;
}
</code></pre>

<h1 id="wildcard-matching">Wildcard Matching</h1>

<p>Link: <a href="https://leetcode.com/problems/wildcard-matching/">Wildcard Matching</a></p>

<h2 id="problem-description-1">Problem description</h2>

<p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement wildcard pattern matching with support for <code>'?'</code> and <code>'*'</code>.</p>

<pre><code>'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
</code></pre>

<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>

<p><strong>Note:</strong></p>

<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>?</code> or <code>*</code>.</li>
</ul>

<p><strong>Example 1:</strong></p>

<pre><code>Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input:
s = &quot;aa&quot;
p = &quot;*&quot;
Output: true
Explanation: '*' matches any sequence.
</code></pre>

<p><strong>Example 3:</strong></p>

<pre><code>Input:
s = &quot;cb&quot;
p = &quot;?a&quot;
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.
</code></pre>

<p><strong>Example 4:</strong></p>

<pre><code>Input:
s = &quot;adceb&quot;
p = &quot;*a*b&quot;
Output: true
Explanation: The first '*' matches the empty sequence, while the second '*' matches the substring &quot;dce&quot;.
</code></pre>

<p><strong>Example 5:</strong></p>

<pre><code>Input:
s = &quot;acdcb&quot;
p = &quot;a*c?b&quot;
Output: false
</code></pre>

<h2 id="method-1">Method</h2>

<p>This problem’s only difference to previous one is the matching field of <code>*</code>. In this problem, the <code>*</code> can match any sequence including empty sequence. Therefore, <code>*</code> is the real wildcard in this problem. If current char in pattern is <code>*</code>, then <code>dp[i + 1][j + 1] = dp[i + 1][j] || dp[i][j + 1]</code>.</p>

<p>Also, this problem can be solved by DFS with memorization. The condition is simpler than previous problem. There will only be these branches:</p>

<ol>
<li>If current char in <code>p</code> is <code>*</code>, then move string index forward or move pattern pattern index forward.</li>
<li>If current char in <code>s</code> and <code>p</code> are equal, or current char in <code>p</code> is <code>?</code>, then move both index forward.</li>
</ol>

<p>See code below.</p>

<h2 id="code-1">Code</h2>

<pre><code class="language-java">/**
 * Dynamic programming with 2D table.
 * Conditions:
 * if (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.') -&gt;  dp[i + 1][j + 1] = dp[i][j]
 * if (p.charAt(j) == '*'): since '*' can match empty string, then directly fill dp[i + 1][j] || dp[i][j + 1]
 * If either condition is satisfied, return false.
 *
 * @param s string
 * @param p pattern string
 * @return if string is matched to pattern
 */
public boolean isMatch(String s, String p) {

    /* Corner case */
    if (s == null || p == null) {
        return false;
    }

    int l1 = s.length(), l2 = p.length();
    boolean[][] dp = new boolean[l1 + 1][l2 + 1];
    dp[0][0] = true;        // empty string matches empty string

    for (int i = 1; i &lt;= l2; i++) {
        if (p.charAt(i - 1) == '*') {
            dp[0][i] = dp[0][i - 1];        // '*' can match empty string
        }
    }

    for (int i = 1; i &lt;= l1; i++) {
        for (int j = 1; j &lt;= l2; j++) {
            if (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '?') {
                dp[i][j] = dp[i - 1][j - 1];
            }
            if (p.charAt(j - 1) == '*') {

                /*
                 * dp[i + 1][j]: matches any sequence 1 ~ n times.
                 * dp[i][j + 1]: matches empty sequence. */
                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
            }
        }
    }

    return dp[l1][l2];
}

public boolean dfsImple(String s, String p) {

    /* Corner case */
    if (p == null || s == null) {
        return false;
    }

    int l1 = s.length(), l2 = p.length();

    /*
     * mem[i][j]: whether string (0, i) and pattern(0, j) is matched.
     * -1: not matched
     * 1: matched
     * 0: don't know */
    int[][] mem = new int[l1 + 1][l2 + 1];

    /*
     * 1. last cell (mem[l1][l2]) should be true (end point of both string and pattern reaches the end)
     * 2. If last char in pattern is '*', then it can match all subsequence as long as previous part is matched. */
    for (int i = l2; i &gt;= 0 &amp;&amp; (i == l2 || (i &lt; l2 &amp;&amp; p.charAt(i) == '*')); i--) {
        mem[l1][i] = 1;
    }

    return dfs(s, p, 0, 0, mem);
}

/**
 * DFS searching with a 2D int table to accomplish pruning.
 * During the searching process, if the table cell has been filled, return the value.
 * mem[i][j]: whether string (0, i) and pattern(0, j) is matched. -1: not matched; 1: matched; 0: don't know
 *
 * @param s   string
 * @param p   pattern string
 * @param i   current index of string
 * @param j   current index of pattern
 * @param mem 2D boolean array to store the previous result
 * @return if string is matched to pattern
 */
private boolean dfs(String s, String p, int i, int j, int[][] mem) {

    if (mem[i][j] != 0) {      // reuse previous result
        return mem[i][j] == 1;
    }

    if (j &gt;= p.length()) {      // avoid overflow
        return false;
    }

    if (p.charAt(j) == '*') {
        if ((i &lt; s.length() &amp;&amp; dfs(s, p, i + 1, j, mem)) || dfs(s, p, i, j + 1, mem)) {
            mem[i][j] = 1;
            return true;
        }
    } else if (i &lt; s.length() &amp;&amp; (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {
        mem[i][j] = dfs(s, p, i + 1, j + 1, mem) ? 1 : -1;      // if
        return mem[i][j] == 1;
    }

    mem[i][j] = -1;
    return false;
}
</code></pre>

<h1 id="edit-distance">Edit Distance</h1>

<p>Link: <a href="https://leetcode.com/problems/edit-distance">Edit Distance</a></p>

<h2 id="problem-description-2">Problem description</h2>

<p>Given two words <em>word1</em> and <em>word2</em>, find the minimum number of operations required to convert <em>word1</em> to <em>word2</em>.</p>

<p>You have the following 3 operations permitted on a word:</p>

<ol>
<li>Insert a character</li>
<li>Delete a character</li>
<li>Replace a character</li>
</ol>

<p><strong>Example 1:</strong></p>

<pre><code>Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
Output: 3
Explanation: 
horse -&gt; rorse (replace 'h' with 'r')
rorse -&gt; rose (remove 'r')
rose -&gt; ros (remove 'e')
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
Output: 5
Explanation: 
intention -&gt; inention (remove 't')
inention -&gt; enention (replace 'i' with 'e')
enention -&gt; exention (replace 'n' with 'x')
exention -&gt; exection (replace 'n' with 'c')
exection -&gt; execution (insert 'u') 
</code></pre>

<h2 id="method-2">Method</h2>

<p>Two approaches. This problem can be solved by both dynamic programming and DFS with pruning.</p>

<p><strong>Dynamic programming</strong></p>

<p>Classic dynamic programming problem. The key to solve this problem is to find out the state transition formula.</p>

<p><code>dp[i][j]</code> = <code>dp[i - 1][j - 1]</code>, if <code>word1.charAt(i - 1) == word2.charAt(j - 1)</code>
Otherwise, <code>dp[i][j]</code> = <code>min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1</code>.</p>

<p>Since each action takes only one weight, it can be directly used.</p>

<p><strong>DFS with pruning</strong></p>

<p>Search starts at the end of string (start will also be fine). If current char is matched</p>

<h2 id="code-2">Code</h2>

<pre><code class="language-java">/**
 * Dynamic programming with a 2D array.
 * State transition:
 * dp[i][j] = dp[i - 1][j - 1], if word1.charAt(i - 1) == word2.charAt(j - 1)
 * dp[i + 1][j + 1] = min(dp[i][j], Math.min(dp[i + 1][j], dp[i][j + 1]) + 1, otherwise.
 *
 * @param word1 string 1
 * @param word2 target converted string
 * @return min edit distance
 */
public int minDistance(String word1, String word2) {
    int l1 = word1.length(), l2 = word2.length();

    /* Corner case */
    if (l1 == 0 || l2 == 0) {
        return word1.length() | word2.length();     // if one is empty, then the min distance is the other word
    }

    if (word1.equals(word2)) {
        return 0;
    }

    int[][] dp = new int[l1 + 1][l2 + 1];

    for (int i = 1; i &lt; l1 + 1; i++) {
        dp[i][0] = i;
    }

    for (int i = 1; i &lt; l2 + 1; i++) {
        dp[0][i] = i;
    }

    for (int i = 1; i &lt; l1 + 1; i++) {
        for (int j = 1; j &lt; l2 + 1; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
            }
        }
    }

    return dp[l1][l2];
}

/**
 * Use DFS to find the min edit distance, with a 2D int array as pruning (without that would cause TLE).
 *
 * @param word1 string 1
 * @param word2 target converted string
 * @return min edit distance
 */
public int dfsImpl(String word1, String word2) {

    int n1 = word1.length(), n2 = word2.length();

    /* Corner case */
    if (n1 == 0 || n2 == 0) {
        return word1.length() | word2.length();     // if one is empty, then the min distance is the other word
    }
    int[][] mem = new int[n1 + 1][n2 + 1];

    for (int[] m : mem) {
        Arrays.fill(m, -1);
    }

    return dfs(word1, word2, n1, n2, mem);
}

/**
 * DFS search.
 * The branch of searching is to check if current character is matched.
 * If matched, then both string move one char forward.
 * Otherwise, three branches: insert, update, delete.
 *
 * @param s1  first string
 * @param s2  target string
 * @param i   index of s1
 * @param j   index of s2
 * @param mem memorization array
 * @return min edit distance
 */
private int dfs(String s1, String s2, int i, int j, int[][] mem) {
    if (i == 0 || j == 0) {
        return j + i;
    }

    if (mem[i][j] != -1) {
        return mem[i][j];
    }

    int insert = dfs(s1, s2, i, j - 1, mem) + 1;
    int delete = dfs(s1, s2, i - 1, j, mem) + 1;

    /*
     * If two chars are matched, then the cost will not change.
     * But both pointer will moving forward (same as replacement)
     * Otherwise, replace operation will cost one. */
    int replace = (s1.charAt(i - 1) == s2.charAt(j - 1)) ? dfs(s1, s2, i - 1, j - 1, mem) : dfs(s1, s2, i - 1, j - 1, mem) + 1;

    int min = Math.min(insert, Math.min(delete, replace));
    mem[i][j] = min;

    return min;
}
</code></pre>

<h1 id="word-break">Word Break</h1>

<p>Link: <a href="https://leetcode.com/problems/word-break">Word Break</a></p>

<h2 id="problem-description-3">Problem description</h2>

<p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated sequence of one or more dictionary words.</p>

<p><strong>Note:</strong></p>

<ul>
<li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
<li>You may assume the dictionary does not contain duplicate words.</li>
</ul>

<p><strong>Example 1:</strong></p>

<pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
Output: true
Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
Output: true
Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.
             Note that you are allowed to reuse a dictionary word.
</code></pre>

<p><strong>Example 3:</strong></p>

<pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
Output: false
</code></pre>

<h2 id="method-3">Method</h2>

<p>The first thought was DFS, and the code is concise and easy. However, DFS would cause a TLE, since it would actually iterate all substring during the iteration. The point of this problem is, a DFS-like problem asked to find out existence, can be accomplished by dynamic programming.</p>

<p>The solution of this problem is use a 1D boolean array <code>dp[]</code>. In the array, if <code>substring(0,i)</code> is valid under problem description, then <code>dp[i]</code> is true.</p>

<p>Therefore, iterate the string from beginning to the end, at each char, traverse from current location to string beginning to see if there is a position that <code>dp[j]</code> is true. If found one, then see if the <code>substring(0,i)</code> is in dictionary. If so, mark <code>dp[i]</code> as true.</p>

<h2 id="code-3">Code</h2>

<pre><code class="language-java">/**
 * Dynamic programming with 1D boolean array.
 * Iterate the given string.
 * Under each substring in iteration, find a breaking point to split both substring exist in dictionary.
 * State transition:
 * dp(i) = true iff dp(j) == true &amp;&amp; dic.contains(s.substring(j, i)), where j &lt;= 0 &lt; i.
 * In substring function, j should be from
 *
 * @param s        given string
 * @param wordDict given dictionary
 * @return if s can be segmented into a space-separated sequence of one or more dictionary words
 */
public boolean wordBreak(String s, List&lt;String&gt; wordDict) {

    /* Corner case */
    if (s.length() == 0 || wordDict.size() == 0) {
        return false;
    }
    HashSet&lt;String&gt; dict = new HashSet&lt;&gt;(wordDict);

    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;       // avoid first char is found in dictionary but marked as false

    for (int i = 1; i &lt; dp.length; i++) {       // iter string
        for (int j = i - 1; j &gt;= 0; j--) {
            /*
             * Split string into s(0, j) and s(j, i).
             * There are two conditions:
             * 1. (0, j) can be previously found in set
             * 2. s(j, i) can be found in set
             * Then s(0, i) can be divided. */
            if (dp[j] &amp;&amp; dict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[s.length()];
}

/**
 * Use DFS with memorization to find if s can be segmented.
 * Use an integer array as memorization to avoid TLE.
 * mem[i] means if s(0, i) can be segmented, where -1 is false, 0 is unknown, 1 is true.
 *
 * @param s        given string
 * @param wordDict given dictionary
 * @return if s can be segmented into a space-separated sequence of one or more dictionary words
 */
public boolean dfsWithMem(String s, List&lt;String&gt; wordDict) {

    /* Corner case */
    if (s.length() == 0 || wordDict.size() == 0) {
        return false;
    }

    HashSet&lt;String&gt; dict = new HashSet&lt;&gt;(wordDict);

    return dfs(s, dict, new int[s.length()], 0);
}

/**
 * Use DFS with memorization to find if s can be segmented. Use an integer array as memorization to avoid TLE.
 *
 * @param s          given string
 * @param dictionary given dictionary
 * @param mem        memorization array
 * @param start      start index
 * @return if s can be segmented into a space-separated sequence of one or more dictionary words
 */
private boolean dfs(String s, HashSet&lt;String&gt; dictionary, int[] mem, int start) {
    if (dictionary.contains(s)) {
        return true;
    }
    if (mem[start] != 0) {
        return mem[start] == 1;
    }

    for (int i = 0; i &lt; s.length(); i++) {
        if (dictionary.contains(s.substring(i)) &amp;&amp; dfs(s.substring(0, i), dictionary, mem, i)) {
            mem[i] = 1;
            return true;
        }
    }

    mem[start] = -1;
    return false;
}
</code></pre>

<h1 id="dice-roll-simulation">Dice Roll Simulation</h1>

<p>Link: <a href="https://leetcode.com/problems/dice-roll-simulation">Dice Roll Simulation</a></p>

<h2 id="problem-description-4">Problem description</h2>

<p>A die simulator generates a random number from 1 to 6 for each roll. You introduced a constraint to the generator such that it cannot roll the number <code>i</code> more than <code>rollMax[i]</code> (1-indexed) <strong>consecutive</strong> times.</p>

<p>Given an array of integers <code>rollMax</code> and an integer <code>n</code>, return the number of distinct sequences that can be obtained with exact <code>n</code> rolls.</p>

<p>Two sequences are considered different if at least one element differs from each other. Since the answer may be too large, return it modulo <code>10^9 + 7</code>.</p>

<p><strong>Example 1:</strong></p>

<pre><code>Input: n = 2, rollMax = [1,1,2,2,2,3]
Output: 34
Explanation: There will be 2 rolls of die, if there are no constraints on the die, there are 6 * 6 = 36 possible combinations. In this case, looking at rollMax array, the numbers 1 and 2 appear at most once consecutively, therefore sequences (1,1) and (2,2) cannot occur, so the final answer is 36-2 = 34.
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input: n = 2, rollMax = [1,1,1,1,1,1]
Output: 30
</code></pre>

<p><strong>Example 3:</strong></p>

<pre><code>Input: n = 3, rollMax = [1,1,1,2,2,3]
Output: 181
</code></pre>

<p><strong>Constraints:</strong></p>

<ul>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>rollMax.length == 6</code></li>
<li><code>1 &lt;= rollMax[i] &lt;= 15</code></li>
</ul>

<h2 id="method-4">Method</h2>

<p>DFS with memorization.</p>

<p>The memorization array stores value under specific remaining dices, roll limit, and dice value.</p>

<p>The constraint of DFS is that, first, if remaining dice is 0, then current dice has only one combination. Second, if consecutive roll has reached the limit, current dice roll can not be the limited value.</p>

<h2 id="code-4">Code</h2>

<pre><code class="language-java">private int MOD = 1000000000 + 7;

/**
 * DFS with memorization.
 * The memorization array stores value under specific remaining dices, roll limit, and dice value.
 *
 * @param n       n dices
 * @param rollMax max consecutive rolls of one dice value
 * @return the number of distinct sequences that can be obtained with exact n rolls
 */
public int dieSimulator(int n, int[] rollMax) {
    int[][][] mem = new int[n][16][6];      // n remaining dices, at most roll 16 times, dice has 6 facet

    int out = 0;
    for (int i = 0; i &lt; 6; i++) {
        out = (out + dfs(mem, rollMax, n - 1, 1, i)) % MOD;     // first dice roll
    }

    return out;
}

/**
 * DFS with memorization.
 * The constraint of DFS is that, first, if remaining dice is 0, then current dice has only one combination.
 * Second, if consecutive roll has reached the limit, current dice roll can not be the limited value.
 * A memorization array is used to store the previous result of specific remaining dice, roll limit and dice value.
 *
 * @param mem         memory array
 * @param max         max consecutive rolls of one dice value
 * @param remaining   remaining dice roll
 * @param consecutive previous consecutive roll
 * @param i           previous dice value
 * @return the number of distinct sequences that can be obtained with exact n rolls
 */
private int dfs(int[][][] mem, int[] max, int remaining, int consecutive, int i) {

    if (remaining == 0) {
        return 1;       // last dice has only one combination
    }

    if (mem[remaining][consecutive][i] != 0) {
        return mem[remaining][consecutive][i];      // memorization
    }

    int out = 0;
    for (int j = 0; j &lt; 6; j++) {
        if (j != i) {
            out = (out + dfs(mem, max, remaining - 1, 1, j)) % MOD;
        } else if (consecutive &lt; max[i]) {
            out = (out + dfs(mem, max, remaining - 1, consecutive + 1, j)) % MOD;
        }
    }

    mem[remaining][consecutive][i] = out;

    return out;
}
</code></pre>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://yyzhou95.github.io/tags/dynamic-programming/">Dynamic Programming</a>

  <a class="tag tag--primary tag--small" href="https://yyzhou95.github.io/tags/dfs/">DFS</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/10/lc-130-surrounded-regions/" data-tooltip="LC 130 - Surrounded Regions">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/10/lc-116/117-populating-next-right-pointers-in-each-node/" data-tooltip="LC 116/117 - Populating Next Right Pointers in Each Node">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 <a href="https://github.com/yyzhou95">BorisMirage</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/10/lc-130-surrounded-regions/" data-tooltip="LC 130 - Surrounded Regions">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/10/lc-116/117-populating-next-right-pointers-in-each-node/" data-tooltip="LC 116/117 - Populating Next Right Pointers in Each Node">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://yyzhou95.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Steve Zhou</h4>
    
      <div id="about-card-bio">Bingo!</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Los Angeles
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://yyzhou95.github.io/img/bg.jpeg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://yyzhou95.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

