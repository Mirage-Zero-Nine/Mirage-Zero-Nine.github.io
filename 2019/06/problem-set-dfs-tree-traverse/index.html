<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.57.2 with theme Tranquilpeak 0.4.7-BETA">
<meta name="author" content="Steve Zhou">
<meta name="keywords" content="">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="Problem Set: DFS Tree Traverse">
<meta name="twitter:title" content="Problem Set: DFS Tree Traverse">
<meta property="og:url" content="https://yyzhou95.github.io/2019/06/problem-set-dfs-tree-traverse/">
<meta property="twitter:url" content="https://yyzhou95.github.io/2019/06/problem-set-dfs-tree-traverse/">
<meta property="og:site_name" content="Bingo!">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2019-06-27T00:00:00">
  
  
    <meta property="article:modified_time" content="2019-06-27T00:00:00">
  
  
  
    
      <meta property="article:section" content="LeetCode Solution">
    
  
  
    
      <meta property="article:tag" content="DFS">
    
      <meta property="article:tag" content="Tree">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://yyzhou95.github.io/img/avatar.jpg">
  <meta property="twitter:image" content="https://yyzhou95.github.io/img/avatar.jpg">


    <title>Problem Set: DFS Tree Traverse</title>

    <link rel="icon" href="https://yyzhou95.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://yyzhou95.github.io/2019/06/problem-set-dfs-tree-traverse/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://yyzhou95.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://yyzhou95.github.io/">Bingo!</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://yyzhou95.github.io/#about">
    
    
    
      
        <img class="header-picture" src="https://yyzhou95.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://yyzhou95.github.io/#about">
          <img class="sidebar-profile-picture" src="https://yyzhou95.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Steve Zhou</h4>
        
          <h5 class="sidebar-profile-bio">Bingo!</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://yyzhou95.github.io/#about">
    
      <i class="sidebar-button-icon fa fa-lg fa-question"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/yyzhou95" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/yyzhou95/yyzhou95.github.io" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-link"></i>
      
      <span class="sidebar-button-desc">Source Code</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="5"
        class="
               hasCoverMetaOut
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-center">
  
    <h1 class="post-title" itemprop="headline">
      Problem Set: DFS Tree Traverse
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2019-06-27T00:00:00Z">
        
  June 27, 2019

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://yyzhou95.github.io/categories/leetcode-solution">LeetCode Solution</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>Links:
- <a href="https://leetcode.com/problems/binary-tree-inorder-traversal">Binary Tree Inorder Traversal</a>
- <a href="https://leetcode.com/problems/binary-tree-preorder-traversal">Binary Tree Preorder Traversal</a>
- <a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list">Flatten Binary Tree to Linked List</a>
- <a href="https://leetcode.com/problems/binary-tree-postorder-traversal">Binary Tree Postorder Traversal</a>
- <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">Binary Tree Paths</a>
- <a href="https://leetcode.com/problems/same-tree/">Same Tree</a>
- <a href="https://leetcode.com/problems/symmetric-tree">Symmetric Tree</a>
- <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree">Maximum Depth of Binary Tree</a>
- <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/">Minimum Depth of Binary Tree</a>
- <a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/">Convert Sorted Array to Binary Search Tree</a>
- <a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/">Convert Sorted List to Binary Search Tree</a>
- <a href="https://leetcode.com/problems/balanced-binary-tree/">Balanced Binary Tree</a>
- <a href="https://leetcode.com/problems/path-sum/">Path Sum</a>
- <a href="https://leetcode.com/problems/path-sum-ii/">Path Sum II</a>
- <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">Sum Root to Leaf Numbers</a>
- <a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/">Insert into a Binary Search Tree</a></p>

<h2 id="binary-tree-inorder-traversal">Binary Tree Inorder Traversal</h2>

<h3 id="problem-description">Problem description</h3>

<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes&rsquo; values.</p>

<p><strong>Example:</strong></p>

<pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
</code></pre>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>

<h3 id="method">Method</h3>

<p>Simply follow the in order traversal rule. Use stack to temporary store node during the process.</p>

<h3 id="code">Code</h3>

<pre><code class="language-java">/**
 * Simply follow the in order traversal rule.
 * Use stack to temporary store node during the process.
 *
 * @param root root node
 * @return in order traversal node value
 */
public List&lt;Integer&gt; inorderTraversal(TreeNode root) {

    LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();
    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
    TreeNode cur = root;

    /* Traverse process */
    while (cur != null || !s.isEmpty()) {

        while (cur != null) {
            s.add(cur);
            cur = cur.left;
        }

        cur = s.pop();
        res.add(cur.val);
        cur = cur.right;
    }

    return res;
}
</code></pre>

<h2 id="binary-tree-preorder-traversal">Binary Tree Preorder Traversal</h2>

<h3 id="problem-description-1">Problem description</h3>

<p>Given a binary tree, return the <em>preorder</em> traversal of its nodes&rsquo; values.</p>

<p><strong>Example:</strong></p>

<pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
</code></pre>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>

<h3 id="method-1">Method</h3>

<p>Use a stack to store nodes. Each time push right subtree to stack, then push left subtree. In this way to keep left subtree at top of stack.</p>

<p>Flatten Binary Tree to Linked List implement the preorder traversal. Simply push the subtree in preorder traversal order and point the right subtree to current node’s right child will be enough.</p>

<p>Do not forget to set <code>null</code> to left subtree.</p>

<h3 id="code-1">Code</h3>

<pre><code class="language-java">/**
 * Use a stack to store nodes.
 * Each time push right subtree to stack, then push left subtree. In this way to keep left subtree at top of stack.
 *
 * @param root root node of tree
 * @return preorder traversal of tree's values
 */
public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; out = new LinkedList&lt;&gt;();

    if (root == null) {
        return out;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();

    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            out.add(node.val);
            stack.push(node.right);
            stack.push(node.left);      // keep left at top of stack
        }
    }

    return out;
}
</code></pre>

<h2 id="flatten-binary-tree-to-linked-list">Flatten Binary Tree to Linked List</h2>

<h3 id="problem-description-2">Problem description</h3>

<p>Given a binary tree, flatten it to a linked list in-place.</p>

<p>For example, given the following tree:</p>

<pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre>

<p>The flattened tree should look like:</p>

<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre>

<h3 id="method-2">Method</h3>

<p>Use a stack to store nodes. Each time push right subtree to stack, then push left subtree. In this way to keep left subtree at top of stack.</p>

<p>Flatten Binary Tree to Linked List implement the preorder traversal. Simply push the subtree in preorder traversal order and point the right subtree to current node’s right child will be enough.</p>

<p>Do not forget to set <code>null</code> to left subtree.</p>

<h3 id="code-2">Code</h3>

<pre><code class="language-java">/**
 * Preorder traversal.
 * Use a stack to store the left subtree and right subtree for later traversal.
 *
 * @param root root node of tree
 */
public void flatten(TreeNode root) {

    if (root == null) {
        return;
    }
    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
    s.push(root);
    while (!s.isEmpty()) {
        TreeNode current = s.pop();
        if (current.right != null) {
            s.push(current.right);
        }
        if (current.left != null) {
            s.push(current.left);       // keep left at top of stack
        }
        current.right = (s.isEmpty()) ? null : s.peek();        // point left subtree to flatten right subtree.
    }
}            current.left = null;

</code></pre>

<h2 id="binary-tree-postorder-traversal">Binary Tree Postorder Traversal</h2>

<h3 id="problem-description-3">Problem description</h3>

<p>Given a binary tree, return the <em>postorder</em> traversal of its nodes&rsquo; values.</p>

<p><strong>Example:</strong></p>

<pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
</code></pre>

<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>

<h3 id="method-3">Method</h3>

<p>Order of preorder traversal is root -&gt; left -&gt; right, and order of postorder traversal is left -&gt; right -&gt; root.</p>

<p>Therefore, add node to the head of result list will suffice the postorder traversal.</p>

<h3 id="code-3">Code</h3>

<pre><code class="language-java">/**
 * Order of preorder traversal is root -&gt; left -&gt; right, and order of postorder traversal is left -&gt; right -&gt; root.
 * Therefore, add node to the head of result list will suffice the postorder traversal.
 * This is same as reverse list.
 *
 * @param root root node
 * @return postorder traversal of tree's values
 */
public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; out = new ArrayList&lt;&gt;();

    /* Corner case */
    if (root == null) {
        return out;
    }

    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();

        if (cur != null) {
            out.add(0, cur.val);        // add current root to the head of list
            stack.push(cur.left);
            stack.push(cur.right);
        }
    }
    return out;
}
</code></pre>

<h2 id="binary-tree-paths">Binary Tree Paths</h2>

<h3 id="problem-description-4">Problem description</h3>

<p>Given a binary tree, return all root-to-leaf paths.</p>

<p><strong>Note:</strong> A leaf is a node with no children.</p>

<p><strong>Example:</strong></p>

<pre><code>Input:

   1
 /   \
2     3
 \
  5

Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre>

<h3 id="method-4">Method</h3>

<p>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree node. The only difference is that during the traversal, first problem check if two nodes in different tree is the same, second problem check if the child node has same value.</p>

<h3 id="code-4">Code</h3>

<pre><code class="language-java">/**
 * Pre-order traversal.
 *
 * @param root root node
 * @return all path from root to leaf
 */
public List&lt;String&gt; binaryTreePaths(TreeNode root) {
    List&lt;String&gt; output = new ArrayList&lt;&gt;();
    if (root != null) {
        dfs(root, &quot;&quot;, output);
    }
    return output;
}

/**
 * Pre-order traversal.
 *
 * @param n      node
 * @param s      path string
 * @param output all path from root to leaf
 */
private void dfs(TreeNode n, String s, List&lt;String&gt; output) {
    if (n.right == null &amp;&amp; n.left == null) {
        output.add(s + n.val);      // end point
    }

    if (n.left != null) {
        dfs(n.left, s + n.val + &quot;-&gt;&quot;, output);
    }
    if (n.right != null) {
        dfs(n.right, s + n.val + &quot;-&gt;&quot;, output);
    }
}
</code></pre>

<h2 id="same-tree">Same Tree</h2>

<h3 id="problem-description-5">Problem description</h3>

<p>Given two binary trees, write a function to check if they are the same or not.</p>

<p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>

<p><strong>Example 1:</strong></p>

<pre><code>Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
</code></pre>

<p><strong>Example 3:</strong></p>

<pre><code>Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
</code></pre>

<h3 id="method-5">Method</h3>

<p>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree node. The only difference is that during the traversal, first problem check if two nodes in different tree is the same, second problem check if the child node has same value.</p>

<h3 id="code-5">Code</h3>

<pre><code class="language-java">/**
 * Any kind of traversal of tree (in-order, post-order, pre-order) will suffice.
 * If sub nodes do not be in same situation (null or not null), return false.
 * If value in tree node is same, continue recursion in sub nodes.
 *
 * @param p TreeNode 1
 * @param q TreeNode 2
 * @return if two trees are same
 */
public boolean isSameTree(TreeNode p, TreeNode q) {

    if (p == null &amp;&amp; q == null) {       // end point
        return true;
    }

    if (p == null || q == null) {       // if given two trees has different child node, return false
        return false;
    }
    if (p.val == q.val) {
        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
    }
    return false;
}
</code></pre>

<h2 id="symmetric-tree">Symmetric Tree</h2>

<h3 id="problem-description-6">Problem description</h3>

<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>

<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>

<pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>

<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>

<pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre>

<h3 id="method-6">Method</h3>

<p>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree node. The only difference is that during the traversal, first problem check if two nodes in different tree is the same, second problem check if the child node has same value.</p>

<h3 id="code-6">Code</h3>

<pre><code class="language-java">/**
 * Pre-order traversal.
 *
 * @param root root TreeNode
 * @return if this tree is symmetric
 */
public boolean isSymmetric(TreeNode root) {

    /* Corner case */
    if (root == null) {
        return true;
    }
    if (root.left == null &amp;&amp; root.right == null) {
        return true;
    }
    if (root.left == null || root.right == null) {
        return false;
    }

    if (root.left.val == root.right.val) {
        return isSymmetricTree(root.left, root.right);
    }

    return false;
}

/**
 * Almost same as IsSameTree_100 problem, only simply modified the recursion to compare left node and right node.
 *
 * @param p TreeNode 1
 * @param q TreeNode 2
 * @return if two trees are symmetric
 */
private boolean isSymmetricTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    if (p.val == q.val) {
        return isSymmetricTree(p.left, q.right) &amp;&amp; isSymmetricTree(p.right, q.left);
    }
    return false;
}
</code></pre>

<h2 id="maximum-depth-of-binary-tree">Maximum Depth of Binary Tree</h2>

<h3 id="problem-description-7">Problem description</h3>

<p>Given a binary tree, find its maximum depth.</p>

<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p><strong>Note:</strong> A leaf is a node with no children.</p>

<p><strong>Example:</strong></p>

<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>

<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>

<p>return its depth = 3.</p>

<h3 id="method-7">Method</h3>

<p>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree node. The only difference is that during the traversal, first problem check if two nodes in different tree is the same, second problem check if the child node has same value.</p>

<h3 id="code-7">Code</h3>

<h2 id="minimum-depth-of-binary-tree">Minimum Depth of Binary Tree</h2>

<h3 id="problem-description-8">Problem description</h3>

<p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p>

<p><strong>Note:</strong> A leaf is a node with no children.</p>

<p><strong>Example:</strong></p>

<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>

<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>

<p>return its minimum depth = 2.</p>

<h3 id="method-8">Method</h3>

<p>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree node. The only difference is that during the traversal, first problem check if two nodes in different tree is the same, second problem check if the child node has same value.</p>

<h3 id="code-8">Code</h3>

<pre><code class="language-java">/**
 * DFS, using pre-order traversal.
 *
 * @param root root node
 * @return max depth.
 */
public int maxDepth(TreeNode root) {

    /* Corner case and end point */
    if (root == null) {
        return 0;
    }

    /* Keep find left sub tree and right sub tree until reaches the end */
    return Integer.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>

<h3 id="minimum-depth-of-binary-tree-1">Minimum Depth of Binary Tree</h3>

<pre><code class="language-java">/**
 * In order traversal.
 *
 * @param root root node
 * @return depth
 */
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int l = minDepth(root.left);
    int r = minDepth(root.right);

    return (l == 0 || r == 0) ? l + r + 1 : Math.min(l, r) + 1;
}
</code></pre>

<h2 id="convert-sorted-array-to-binary-search-tree">Convert Sorted Array to Binary Search Tree</h2>

<h3 id="problem-description-9">Problem description</h3>

<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>

<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>

<p><strong>Example:</strong></p>

<pre><code>Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>

<h3 id="method-9">Method</h3>

<h3 id="code-9">Code</h3>

<pre><code class="language-java">/**
 * Root of the tree is at the mid of array and sub array.
 *
 * @param nums given num array
 * @return height balanced BST
 */
public TreeNode sortedArrayToBST(int[] nums) {

    /* */
    if (nums.length &lt; 2) {
        return (nums.length == 0 ? null : new TreeNode(nums[0]));
    }

    return builder(nums, 0, nums.length - 1);
}

/**
 * Pre-order traversal.
 *
 * @param num   given num array
 * @param start start index
 * @param end   end index
 * @return root of height balanced BST
 */
private TreeNode builder(int[] num, int start, int end) {

    /* End point */
    if (start &gt; end) {
        return null;
    }

    int mid = (start + end) / 2;

    TreeNode root = new TreeNode(num[mid]);

    root.left = builder(num, start, mid - 1);
    root.right = builder(num, mid + 1, end);
    return root;
}
</code></pre>

<h2 id="convert-sorted-list-to-binary-search-tree">Convert Sorted List to Binary Search Tree</h2>

<h3 id="problem-description-10">Problem description</h3>

<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>

<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>

<p><strong>Example:</strong></p>

<pre><code>Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>

<h3 id="method-10">Method</h3>

<p>The only difference between this problem and previous problem is the the linked list can not directly access the elements inside list by index.</p>

<p>Therefore, to locate the root in the list, two pointers are acquired: one <code>fast</code>, one <code>slow</code>. <code>fast</code> will move two nodes forward each time, while <code>slow</code> will only move one forward. In this way, when <code>fast</code> reaches the end of list, <code>slow</code> will be just at the middle of list, which is the root node.</p>

<h3 id="code-10">Code</h3>

<pre><code class="language-java">/**
 * Linked list can not directly get item by index.
 * Therefore, use two pointers to traverse the linked list
 * When faster one reaches the end of list, slow one will be at root (middle of linked list).
 *
 * @param head head node
 * @return root of height balanced BST
 */
public TreeNode sortedListToBST(ListNode head) {

    /* Corner case */
    if (head == null) {
        return null;
    }

    return builder(head, null);
}

/**
 * Use two pointer to find root node.
 * Fast node moves two time faster than slow node.
 * In this way, if fast node reaches the end, slow node will accurately at the mid of list, which is root.
 *
 * @param head head node
 * @param tail end node
 * @return root of height balanced BST
 */
public TreeNode builder(ListNode head, ListNode tail) {

    ListNode slow = head;       // find root (in the mid of linked list)
    ListNode fast = head;       // two time faster move speed

    if (head == tail) {
        return null;
    }

    while (fast != tail &amp;&amp; fast.next != tail) {
        fast = fast.next.next;      // when fast reaches the end, slow will be at mid of list
        slow = slow.next;           // stop at root
    }

    TreeNode root = new TreeNode(slow.val);
    root.left = builder(head, slow);
    root.right = builder(slow.next, tail);

    return root;
}
</code></pre>

<h2 id="balanced-binary-tree">Balanced Binary Tree</h2>

<h3 id="problem-description-11">Problem description</h3>

<p>Given a binary tree, determine if it is height-balanced.</p>

<p>For this problem, a height-balanced binary tree is defined as:</p>

<blockquote>
<p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
</blockquote>

<p><strong>Example 1:</strong></p>

<p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>

<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>

<p>Return true.</p>

<p><strong>Example 2:</strong></p>

<p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>

<pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</code></pre>

<p>Return false.</p>

<h3 id="method-11">Method</h3>

<p>Use DFS to traversal tree and return the height of tree. If current is an imbalanced tree, or the sub tree is height-imbalanced, return -1.</p>

<h3 id="code-11">Code</h3>

<pre><code class="language-java">/**
 * DFS traversal.
 *
 * @param root root node
 * @return if given tree is height-balanced
 */
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }

    return dfs(root) != -1;
}

/**
 * DFS traversal. If current tree has a imbalanced tree, return -1.
 * Otherwise return the height difference.
 *
 * @param root root node
 * @return if given tree is height-balanced
 */
private int dfs(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int left = dfs(root.left);
    int right = dfs(root.right);

    if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) {      // left/right/current tree is not height-balanced
        return -1;      // sub tree is not height-balanced
    }

    return Math.max(left, right) + 1;       // depth + 1
}
</code></pre>

<h2 id="path-sum">Path Sum</h2>

<h3 id="problem-description-12">Problem description</h3>

<p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>

<p><strong>Note:</strong> A leaf is a node with no children.</p>

<p><strong>Example:</strong></p>

<p>Given the below binary tree and <code>sum = 22</code>,</p>

<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre>

<p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>

<h3 id="method-12">Method</h3>

<p>Post-order traversal to find each path from root to leaf, and compare the node value to sum to see if there a path that is equals to given value.</p>

<p>Path Sum II is actually a backtracking process. Therefore, add a linked list during the traversal process will suffice the requirement of problem.</p>

<h3 id="code-12">Code</h3>

<pre><code class="language-java">/**
 * DFS Tree traversal.
 *
 * @param root root node
 * @param sum  given sum
 * @return if it has a root-to-leaf path such that sum of all values along the path equals the given sum
 */
public boolean hasPathSum(TreeNode root, int sum) {

    if (root == null) {
        return false;
    }

    if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val) {
        return true;
    }

    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
</code></pre>

<h2 id="path-sum-ii">Path Sum II</h2>

<h3 id="problem-description-13">Problem description</h3>

<p>Given a binary tree and a sum, find all root-to-leaf paths where each path&rsquo;s sum equals the given sum.</p>

<p><strong>Note:</strong> A leaf is a node with no children.</p>

<p><strong>Example:</strong></p>

<p>Given the below binary tree and <code>sum = 22</code>,</p>

<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre>

<p>Return:</p>

<pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre>

<h3 id="method-13">Method</h3>

<p>Post-order traversal to find each path from root to leaf, and compare the node value to sum to see if there a path that is equals to given value.</p>

<p>Path Sum II is actually a backtracking process. Therefore, add a linked list during the traversal process will suffice the requirement of problem.</p>

<h3 id="code-13">Code</h3>

<pre><code class="language-java">/**
 * DFS.
 *
 * @param root root tree node
 * @param sum  given sum
 * @return all root-to-leaf paths where each path's sum equals the given sum
 */
public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if (root == null) {
        return res;
    }
    dfs(root, sum, res, new ArrayList&lt;&gt;());

    return res;
}


/**
 * Running DFS to find all possible path.
 *
 * @param r     current root node
 * @param sum   required sum
 * @param res   path list
 * @param cache temporary path list
 * @return all root-to-leaf paths sum equals the given sum
 */
private List&lt;List&lt;Integer&gt;&gt; dfs(TreeNode r, int sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cache) {

    cache.add(r.val);

    if (r.left == null &amp;&amp; r.right == null &amp;&amp; r.val == sum) {
        res.add(new ArrayList&lt;&gt;(cache));

    } else {
        if (r.left != null) {
            dfs(r.left, sum - r.val, res, cache);
        }
        if (r.right != null) {
            dfs(r.right, sum - r.val, res, cache);
        }
    }

    cache.remove(cache.size() - 1);

    return res;
}
</code></pre>

<h2 id="sum-root-to-leaf-numbers">Sum Root to Leaf Numbers</h2>

<h3 id="problem-description-14">Problem description</h3>

<p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent a number.</p>

<p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number <code>123</code>.</p>

<p>Find the total sum of all root-to-leaf numbers.</p>

<p><strong>Note:</strong> A leaf is a node with no children.</p>

<p><strong>Example:</strong></p>

<pre><code>Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
</code></pre>

<p><strong>Example 2:</strong></p>

<pre><code>Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.
The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.
The root-to-leaf path 4-&gt;0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
</code></pre>

<h3 id="method-14">Method</h3>

<p>DFS traverse all nodes in tree from top to bottom, and then from bottom to top. Each time add total value to final result with power of 10.</p>

<h3 id="code-14">Code</h3>

<pre><code class="language-java">/**
 * DFS.
 *
 * @param root root node
 * @return total sum of all root-to-leaf numbers
 */
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}

/**
 * Add each node's value with 10^n
 *
 * @param r root node
 * @param n power
 * @return total sum of all root-to-leaf numbers
 */
public int dfs(TreeNode r, int n) {

    /* End point */
    if (r == null) {
        return 0;
    }

    if (r.right == null &amp;&amp; r.left == null) {
        return n * 10 + r.val;
    }

    return dfs(r.left, n * 10 + r.val) + dfs(r.right, n * 10 + r.val);
}
</code></pre>

<h2 id="insert-into-a-binary-search-tree">Insert into a Binary Search Tree</h2>

<h3 id="problem-description-15">Problem description</h3>

<p>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</p>

<p>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>

<p>For example,</p>

<pre><code>Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
</code></pre>

<p>You can return this binary search tree:</p>

<pre><code>         4
       /   \
      2     7
     / \   /
    1   3 5
</code></pre>

<p>This tree is also valid:</p>

<pre><code>         5
       /   \
      2     7
     / \   
    1   3
         \
          4
</code></pre>

<h3 id="method-15">Method</h3>

<p>Insert new node to tree’s correct leaf by binary searching to the end.</p>

<h3 id="code-15">Code</h3>

<pre><code class="language-java">/**
 * Insert new node to correct subtree of leaf.
 *
 * @param root root node
 * @param val  value to be insert
 * @return BST with inserted value
 */
public TreeNode insertIntoBST(TreeNode root, int val) {

    /* Corner case and end point */
    if (root == null) {
        return new TreeNode(val);
    }

    if (val &lt; root.val) {
        root.left = insertIntoBST(root.left, val);
    } else if (val &gt; root.val) {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}
</code></pre>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://yyzhou95.github.io/tags/dfs/">DFS</a>

  <a class="tag tag--primary tag--small" href="https://yyzhou95.github.io/tags/tree/">Tree</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/06/largest-rectangle-in-histogram/" data-tooltip="Largest Rectangle in Histogram">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/06/verify-order-sequence-in-binary-search-tree/" data-tooltip="Verify Order Sequence in Binary Search Tree">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 Steve Zhou. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/06/largest-rectangle-in-histogram/" data-tooltip="Largest Rectangle in Histogram">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://yyzhou95.github.io/2019/06/verify-order-sequence-in-binary-search-tree/" data-tooltip="Verify Order Sequence in Binary Search Tree">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://yyzhou95.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Steve Zhou</h4>
    
      <div id="about-card-bio">Bingo!</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Los Angeles
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://yyzhou95.github.io/img/bg.jpeg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://yyzhou95.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

