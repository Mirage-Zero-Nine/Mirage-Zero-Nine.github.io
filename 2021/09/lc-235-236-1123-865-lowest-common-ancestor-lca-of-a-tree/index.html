<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.88.1 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="Notebook">
<meta name="keywords" content="">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="LC 235 236 1123 865 - Lowest Common Ancestor (LCA) of a Tree">
<meta name="twitter:title" content="LC 235 236 1123 865 - Lowest Common Ancestor (LCA) of a Tree">
<meta property="og:url" content="https://mirage-zero-nine.github.io/2021/09/lc-235-236-1123-865-lowest-common-ancestor-lca-of-a-tree/">
<meta property="twitter:url" content="https://mirage-zero-nine.github.io/2021/09/lc-235-236-1123-865-lowest-common-ancestor-lca-of-a-tree/">
<meta property="og:site_name" content="Bingo!">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2021-09-25T00:00:00">
  
  
    <meta property="article:modified_time" content="2021-09-25T00:00:00">
  
  
  
    
      <meta property="article:section" content="Tree">
    
      <meta property="article:section" content="Binary Search Tree">
    
  
  
    
      <meta property="article:tag" content="DFS">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://mirage-zero-nine.github.io/img/avatar.jpg">
  <meta property="twitter:image" content="https://mirage-zero-nine.github.io/img/avatar.jpg">


    <title>LC 235 236 1123 865 - Lowest Common Ancestor (LCA) of a Tree</title>

    <link rel="icon" href="https://mirage-zero-nine.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://mirage-zero-nine.github.io/2021/09/lc-235-236-1123-865-lowest-common-ancestor-lca-of-a-tree/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://mirage-zero-nine.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://mirage-zero-nine.github.io/css/about.css">
      
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="2">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://mirage-zero-nine.github.io/">Bingo!</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://mirage-zero-nine.github.io/about">
    
    
    
      
        <img class="header-picture" src="https://mirage-zero-nine.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="2">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://mirage-zero-nine.github.io/about">
          <img class="sidebar-profile-picture" src="https://mirage-zero-nine.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Notebook</h4>
        
          <h5 class="sidebar-profile-bio">Bingo!</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/categories/notes/">
    
      <i class="sidebar-button-icon fa fa-lg fa-sticky-note"></i>
      
      <span class="sidebar-button-desc">Notebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="2"
        class="
               hasCoverMetaOut
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      LC 235 236 1123 865 - Lowest Common Ancestor (LCA) of a Tree
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2021-09-25T00:00:00Z">
        
  September 25, 2021

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://mirage-zero-nine.github.io/categories/tree">Tree</a>, 
    
      <a class="category-link" href="https://mirage-zero-nine.github.io/categories/binary-search-tree">Binary Search Tree</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <h1 id="table-of-contents">Table of Contents</h1><nav id="TableOfContents">
  <ul>
    <li><a href="#235-lowest-common-ancestor-of-a-binary-search-tree">235. Lowest Common Ancestor of a Binary Search Tree</a>
      <ul>
        <li><a href="#problem-description">Problem Description</a></li>
        <li><a href="#method--code">Method &amp; Code</a>
          <ul>
            <li><a href="#iterative">Iterative</a></li>
            <li><a href="#recursive">Recursive</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#236-lowest-common-ancestor-of-a-binary-tree">236. Lowest Common Ancestor of a Binary Tree</a>
      <ul>
        <li><a href="#problem-description-1">Problem Description</a></li>
        <li><a href="#method--code-1">Method &amp; Code</a>
          <ul>
            <li><a href="#dfs-post-order-traverse">DFS (Post-order traverse)</a></li>
            <li><a href="#bfs">BFS</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#1123-lowest-common-ancestor-of-deepest-leaves">1123. Lowest Common Ancestor of Deepest Leaves</a>
      <ul>
        <li><a href="#problem-description-2">Problem Description</a></li>
        <li><a href="#method--code-2">Method &amp; Code</a></li>
      </ul>
    </li>
    <li><a href="#smallest-subtree-with-all-the-deepest-nodes">Smallest Subtree with all the Deepest Nodes</a>
      <ul>
        <li><a href="#problem-description-3">Problem Description</a></li>
        <li><a href="#method--code-3">Method &amp; Code</a></li>
      </ul>
    </li>
  </ul>
</nav>
<h1 id="235-lowest-common-ancestor-of-a-binary-search-tree">235. Lowest Common Ancestor of a Binary Search Tree</h1>
<p>Link: <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree">Lowest Common Ancestor of a Binary Search Tree</a></p>
<h2 id="problem-description">Problem Description</h2>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><strong>Example 1:</strong></p>
<pre tabindex="0"><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
</code></pre><p><strong>Example 2:</strong></p>
<pre tabindex="0"><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>All of the nodes' values will be unique.</li>
<li>p and q are different and both values will exist in the BST.</li>
</ul>
<h2 id="method--code">Method &amp; Code</h2>
<p>Smaller node will be left part of BST, while larger node will be in right part of BST.</p>
<ul>
<li>If <code>p &lt; root &lt; q</code>, then root is LCA.</li>
<li>If <code>(root - p) * (root - q) &gt; 0</code>, then they will be both left or right, depend on p and q&rsquo;s value.</li>
</ul>
<h3 id="iterative">Iterative</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Smaller node will be left part of BST, while larger node will be in right part of BST.
</span><span style="color:#75715e"> * Therefore, if p &lt; root &lt; q, then root is LCA.
</span><span style="color:#75715e"> * If (root - p) * (root - q) &gt; 0, then they will be both left or right, depend on p and q&#39;s value.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node
</span><span style="color:#75715e"> * @param p    node
</span><span style="color:#75715e"> * @param q    node
</span><span style="color:#75715e"> * @return lowest common ancestor
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">lowestCommonAncestor</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> TreeNode p<span style="color:#f92672">,</span> TreeNode q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">,</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">-</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">*</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">-</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&gt;</span> max <span style="color:#f92672">?</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">:</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="recursive">Recursive</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Smaller node will be left part of BST, while larger node will be in right part of BST.
</span><span style="color:#75715e"> * Therefore, if p &lt; root &lt; q, then root is LCA.
</span><span style="color:#75715e"> * If (root - p) * (root - q) &gt; 0, then they will be both left or right, depend on p and q&#39;s value.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node
</span><span style="color:#75715e"> * @param p    node
</span><span style="color:#75715e"> * @param q    node
</span><span style="color:#75715e"> * @return lowest common ancestor
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">lowestCommonAncestor</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> TreeNode p<span style="color:#f92672">,</span> TreeNode q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">-</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">*</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">-</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">&lt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&gt;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> lowestCommonAncestor<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> lowestCommonAncestor<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="236-lowest-common-ancestor-of-a-binary-tree">236. Lowest Common Ancestor of a Binary Tree</h1>
<p>Link: <a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/">Lowest Common Ancestor of a Binary Tree</a></p>
<h2 id="problem-description-1">Problem Description</h2>
<p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow <strong>a node to be a descendant of itself</strong>).”</p>
<p>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<p><strong>Example 1:</strong></p>
<pre tabindex="0"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
</code></pre><p><strong>Example 2:</strong></p>
<pre tabindex="0"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</code></pre><p><strong>Note:</strong></p>
<ul>
<li>All of the nodes' values will be unique.</li>
<li>p and q are different and both values will exist in the binary tree.</li>
</ul>
<h2 id="method--code-1">Method &amp; Code</h2>
<p>Two conditions:</p>
<p>Two conditions:</p>
<ol>
<li>p and q are under same tree node, or under different part of root&rsquo;s subtree -&gt; this tree node is the LCA</li>
<li>One of p or q is the LCA -&gt; LCA is p or q</li>
</ol>
<p>Implement the post-order traverse, based on how post-order traverse works, it will start at deepest node.</p>
<ul>
<li>If found p or q, return current node, since LCA will be this node or its parents</li>
<li>If one subtree return null, then return the other half. If the other half returns a node, then the LCA could be the node, or its parents (only one node exists in the subtree). If the other half returns null, then LCA does not exist in this subtree. No matter which result, it should be directly passed to its parent node.</li>
<li>If both left and right has a return node, then the current node is LCA, return current node.</li>
</ul>
<p>Note that the only cases which re-write the return node value is when current node is p or q, or current node is the LCA (both left and right subtree returns a node). In other cases, only the search result will be passed through.</p>
<h3 id="dfs-post-order-traverse">DFS (Post-order traverse)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * DFS (Post-order traverse).
</span><span style="color:#75715e"> * Two conditions:
</span><span style="color:#75715e"> * 1. p and q are under same tree node, or under different part of root&#39;s subtree -&gt; this tree node is the LCA
</span><span style="color:#75715e"> * 2. One of p or q is the LCA -&gt; LCA is p or q
</span><span style="color:#75715e"> * During the post-order traverse:
</span><span style="color:#75715e"> * - Based on how post-order traverse works, it will start at deepest node.
</span><span style="color:#75715e"> * - If found p or q, return current node, since LCA will be this node or its parents
</span><span style="color:#75715e"> * - If left subtree return null, then return the other half, since LCA will only be in the other half, or parents.
</span><span style="color:#75715e"> * - If both left and right has a return node, then the current node is LCA, return current node.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node
</span><span style="color:#75715e"> * @param p    first node
</span><span style="color:#75715e"> * @param q    second node
</span><span style="color:#75715e"> * @return lowest common ancestor (LCA) of two given nodes
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">lowestCommonAncestor</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> TreeNode p<span style="color:#f92672">,</span> TreeNode q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case and end point */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">==</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">||</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">==</span> q<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span> <span style="color:#75715e">// if LCA is one of the p or q, then the search can stop when hit p or q.
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    TreeNode left <span style="color:#f92672">=</span> lowestCommonAncestor<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span>   <span style="color:#75715e">// search in left subtree
</span><span style="color:#75715e"></span>    TreeNode right <span style="color:#f92672">=</span> lowestCommonAncestor<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> p<span style="color:#f92672">,</span> q<span style="color:#f92672">);</span> <span style="color:#75715e">// search in right subtree
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> right<span style="color:#f92672">;</span> <span style="color:#75715e">// right subtree may contain LCA which passed to parent node, or return null if no found 
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> left<span style="color:#f92672">;</span>  <span style="color:#75715e">// no p or q in both subtree, return null
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span> <span style="color:#75715e">// both node found in subtree, hence current node is LCA
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><h3 id="bfs">BFS</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * BFS + HashMap + HashSet.
</span><span style="color:#75715e"> * HashMap save node&#39;s ancestor, HashSet save ancestor when trace back from p (or q).
</span><span style="color:#75715e"> * Use BFS to find p and q, with a hash map to save the parents.
</span><span style="color:#75715e"> * Then trace back to p, use a hash set to save the ancestor during tracing back until reach root.
</span><span style="color:#75715e"> * Do the same thing on q, if there is any ancestor of q is in set, return this node.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node
</span><span style="color:#75715e"> * @param p    first node
</span><span style="color:#75715e"> * @param q    second node
</span><span style="color:#75715e"> * @return lowest common ancestor (LCA) of two given nodes
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">lowestCommonAncestor</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> TreeNode p<span style="color:#f92672">,</span> TreeNode q<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    Queue<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> queue <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
    queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
    HashMap<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">,</span> TreeNode<span style="color:#f92672">&gt;</span> m <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
    m<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>m<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>p<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>m<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>q<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        TreeNode current <span style="color:#f92672">=</span> queue<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
                m<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> current<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                queue<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
                m<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> current<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    HashSet<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>p <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        s<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
        p <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>p<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>q<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        q <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>q<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> q<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="1123-lowest-common-ancestor-of-deepest-leaves">1123. Lowest Common Ancestor of Deepest Leaves</h1>
<p>Link: <a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">Lowest Common Ancestor of Deepest Leaves</a></p>
<h2 id="problem-description-2">Problem Description</h2>
<p>Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.</p>
<p>Recall that:</p>
<ul>
<li>The node of a binary tree is a <em>leaf</em> if and only if it has no children</li>
<li>The <em>depth</em> of the root of the tree is 0, and if the depth of a node is <code>d</code>, the depth of each of its children is <code>d+1</code>.</li>
<li>The <em>lowest common ancestor</em> of a set <code>S</code> of nodes is the node <code>A</code> with the largest depth such that every node in S is in the subtree with root <code>A</code>.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre tabindex="0"><code>Input: root = [1,2,3]
Output: [1,2,3]
Explanation: 
The deepest leaves are the nodes with values 2 and 3.
The lowest common ancestor of these leaves is the node with value 1.
The answer returned is a TreeNode object (not an array) with serialization &quot;[1,2,3]&quot;.
</code></pre><p><strong>Example 2:</strong></p>
<pre tabindex="0"><code>Input: root = [1,2,3,4]
Output: [4]
</code></pre><p><strong>Example 3:</strong></p>
<pre tabindex="0"><code>Input: root = [1,2,3,4,5]
Output: [2,4,5] 
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>The given tree will have between 1 and 1000 nodes.</li>
<li>Each node of the tree will have a distinct value between 1 and 1000.</li>
</ul>
<h2 id="method--code-2">Method &amp; Code</h2>
<p>DFS to find the LCA of the deepest leaves. Note that if there is only one node at the last level of tree, then the LCA is this leave itself.</p>
<p>Keep a int to store the height of the tree. There is at least one leaf node at tree height, which is the deepest leaf. The target LCA&rsquo;s left and right subtree should both connect to the deepest leaf. If a node&rsquo;s left and right subtree has same depth, and they are equal to the height, then it is the target LCA. This means the depth passed by its left and right subtree should be same.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
TreeNode lca <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>        <span style="color:#75715e">// LCA of deepest leaves
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * DFS (post-order traverse) to find the LCA of the deepest leaves.
</span><span style="color:#75715e"> * Note that if there is only one node at the last level of tree, then the LCA is this leave itself.
</span><span style="color:#75715e"> * Keep an integer to store the height of the tree.
</span><span style="color:#75715e"> * There is at least one leaf node at tree height, which is the deepest leaf.
</span><span style="color:#75715e"> * If a node&#39;s left and right subtree has same depth and they are equal to the height, then it is the target LCA.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of the tree
</span><span style="color:#75715e"> * @return the lowest common ancestor of its deepest leaves
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">lcaDeepestLeaves</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> lca<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * DFS to find the LCA of the deepest leaves.
</span><span style="color:#75715e"> * If current node is LCA of the deepest leaves, then the depth of left and right subtree should be the same.
</span><span style="color:#75715e"> * Also, the depth of two subtrees should be the same to the max depth.
</span><span style="color:#75715e"> * This means the depth passed by its left and right subtree should be same.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root  current node
</span><span style="color:#75715e"> * @param depth depth of current node
</span><span style="color:#75715e"> * @return max depth of left and right subtree
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> depth<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    height <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>height<span style="color:#f92672">,</span> depth<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> depth<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> depth <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> depth <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">==</span> right <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">==</span> height<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>     <span style="color:#75715e">// if left and right subtree has same depth, and same as the height
</span><span style="color:#75715e"></span>        lca <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>                             <span style="color:#75715e">// then the LCA of deepest leaves is found
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>left<span style="color:#f92672">,</span> right<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="smallest-subtree-with-all-the-deepest-nodes">Smallest Subtree with all the Deepest Nodes</h1>
<p>Link: <a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes/">Smallest Subtree with all the Deepest Nodes</a></p>
<h2 id="problem-description-3">Problem Description</h2>
<p>Given the <code>root</code> of a binary tree, the depth of each node is <strong>the shortest distance to the root</strong>.</p>
<p>Return <em>the smallest subtree</em> such that it contains <strong>all the deepest nodes</strong> in the original tree.</p>
<p>A node is called <strong>the deepest</strong> if it has the largest depth possible among any node in the entire tree.</p>
<p>The <strong>subtree</strong> of a node is tree consisting of that node, plus the set of all descendants of that node.</p>
<p><strong>Note:</strong> This question is the same as 1123: <a href="https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/">https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/</a></p>
<p><strong>Example 1:</strong></p>
<p><img src="../../../img/sketch1.png" alt="img"></p>
<pre tabindex="0"><code>Input: root = [3,5,1,6,2,0,8,null,null,7,4]
Output: [2,7,4]
Explanation: We return the node with value 2, colored in yellow in the diagram.
The nodes coloured in blue are the deepest nodes of the tree.
Notice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.
</code></pre><p><strong>Example 2:</strong></p>
<pre tabindex="0"><code>Input: root = [1]
Output: [1]
Explanation: The root is the deepest node in the tree.
</code></pre><p><strong>Example 3:</strong></p>
<pre tabindex="0"><code>Input: root = [0,1,3,null,2]
Output: [2]
Explanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree will be in the range <code>[1, 500]</code>.</li>
<li><code>0 &lt;= Node.val &lt;= 500</code></li>
<li>The values of the nodes in the tree are <strong>unique</strong>.</li>
</ul>
<h2 id="method--code-3">Method &amp; Code</h2>
<p>Identical question. To find the subtree with all deepest is the same to find the LCA of all deepest leave nodes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> height <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
TreeNode lca <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>        <span style="color:#75715e">// LCA of deepest leaves
</span><span style="color:#75715e"></span>
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Identical question as 1123.
</span><span style="color:#75715e"> * To find the subtree with all deepest is the same to find the LCA of all deepest leave nodes.
</span><span style="color:#75715e"> * DFS (post-order traverse) to find the LCA of the deepest leaves.
</span><span style="color:#75715e"> * Note that if there is only one node at the last level of tree, then the LCA is this leave itself.
</span><span style="color:#75715e"> * Keep an integer to store the height of the tree.
</span><span style="color:#75715e"> * There is at least one leaf node at tree height, which is the deepest leaf.
</span><span style="color:#75715e"> * If a node&#39;s left and right subtree has same depth and they are equal to the height, then it is the target LCA.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of the tree
</span><span style="color:#75715e"> * @return the lowest common ancestor of its deepest leaves
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">subtreeWithAllDeepest</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> lca<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * DFS to find the LCA of the deepest leaves.
</span><span style="color:#75715e"> * If current node is LCA of the deepest leaves, then the depth of left and right subtree should be the same.
</span><span style="color:#75715e"> * Also, the depth of two subtrees should be the same to the max depth.
</span><span style="color:#75715e"> * This means the depth passed by its left and right subtree should be same.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root  current node
</span><span style="color:#75715e"> * @param depth depth of current node
</span><span style="color:#75715e"> * @return max depth of left and right subtree
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> depth<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    height <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>height<span style="color:#f92672">,</span> depth<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> depth<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    depth<span style="color:#f92672">++;</span>
    <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> depth<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> depth<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">==</span> right <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">==</span> height<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>     <span style="color:#75715e">// if left and right subtree has same depth, and same as the height
</span><span style="color:#75715e"></span>        lca <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>                             <span style="color:#75715e">// then the LCA of deepest leaves is found
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>left<span style="color:#f92672">,</span> right<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://mirage-zero-nine.github.io/tags/dfs/">DFS</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2021/09/lc-11-28-88-125-151-186-557-283-344-345-524-977-1023-1221-1332-basic-two-pointers-problems/" data-tooltip="LC 11 28 88 125 151 186 557 283 344 345 524 977 1023 1221 1332 - Basic Two Pointers Problems">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2021/09/lc-30-substring-with-concatenation-of-all-words/" data-tooltip="LC 30 - Substring with Concatenation of All Words">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 <a href="https://miragespace.me/">BorisMirage</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2021/09/lc-11-28-88-125-151-186-557-283-344-345-524-977-1023-1221-1332-basic-two-pointers-problems/" data-tooltip="LC 11 28 88 125 151 186 557 283 344 345 524 977 1023 1221 1332 - Basic Two Pointers Problems">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2021/09/lc-30-substring-with-concatenation-of-all-words/" data-tooltip="LC 30 - Substring with Concatenation of All Words">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="2">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://mirage-zero-nine.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Notebook</h4>
    
      <div id="about-card-bio">Bingo!</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Seattle
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://mirage-zero-nine.github.io/img/bg.jpeg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://mirage-zero-nine.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

