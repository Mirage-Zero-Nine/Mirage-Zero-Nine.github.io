<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Hugo 0.85.0 with theme Tranquilpeak 0.4.8-BETA">
<meta name="author" content="Notebook">
<meta name="keywords" content="">
<meta name="description" content="">


<meta property="og:description" content="">
<meta property="og:type" content="article">
<meta property="og:title" content="LC 94 98 700 1214 1305 1382 1522 - Tree Traversal: Inorder">
<meta name="twitter:title" content="LC 94 98 700 1214 1305 1382 1522 - Tree Traversal: Inorder">
<meta property="og:url" content="https://mirage-zero-nine.github.io/2020/07/lc-94-98-700-1214-1305-1382-1522-tree-traversal-inorder/">
<meta property="twitter:url" content="https://mirage-zero-nine.github.io/2020/07/lc-94-98-700-1214-1305-1382-1522-tree-traversal-inorder/">
<meta property="og:site_name" content="Bingo!">
<meta property="og:description" content="">
<meta name="twitter:description" content="">
<meta property="og:locale" content="en-us">

  
    <meta property="article:published_time" content="2020-07-24T00:00:00">
  
  
    <meta property="article:modified_time" content="2020-07-24T00:00:00">
  
  
  
    
      <meta property="article:section" content="Tree">
    
      <meta property="article:section" content="Binary Search Tree">
    
      <meta property="article:section" content="N-Ary Tree">
    
  
  
    
      <meta property="article:tag" content="DFS">
    
  


<meta name="twitter:card" content="summary">











  <meta property="og:image" content="https://mirage-zero-nine.github.io/img/avatar.jpg">
  <meta property="twitter:image" content="https://mirage-zero-nine.github.io/img/avatar.jpg">


    <title>LC 94 98 700 1214 1305 1382 1522 - Tree Traversal: Inorder</title>

    <link rel="icon" href="https://mirage-zero-nine.github.io/favicon.png">
    

    

    <link rel="canonical" href="https://mirage-zero-nine.github.io/2020/07/lc-94-98-700-1214-1305-1382-1522-tree-traversal-inorder/">

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.min.css" integrity="sha256-vuXZ9LGmmwtjqFX1F+EKin1ThZMub58gKULUyf0qECk=" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" integrity="sha256-SEa4XYAHihTcEP1f5gARTB2K26Uk8PsndQYHQC1f4jU=" crossorigin="anonymous" />
    
    
    <link rel="stylesheet" href="https://mirage-zero-nine.github.io/css/style-twzjdbqhmnnacqs0pwwdzcdbt8yhv8giawvjqjmyfoqnvazl0dalmnhdkvp7.min.css" />
    
    
      
        <link rel="stylesheet"  href="https://mirage-zero-nine.github.io/css/about.css">
      
    

    
      
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="2">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="header-title">
    <a class="header-title-link" href="https://mirage-zero-nine.github.io/">Bingo!</a>
  </div>
  
    
      <a class="header-right-picture "
         href="https://mirage-zero-nine.github.io/about">
    
    
    
      
        <img class="header-picture" src="https://mirage-zero-nine.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
      
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="2">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="https://mirage-zero-nine.github.io/about">
          <img class="sidebar-profile-picture" src="https://mirage-zero-nine.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
        </a>
        <h4 class="sidebar-profile-name">Notebook</h4>
        
          <h5 class="sidebar-profile-bio">Bingo!</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/">
    
      <i class="sidebar-button-icon fa fa-lg fa-home"></i>
      
      <span class="sidebar-button-desc">Home</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/categories/notes/">
    
      <i class="sidebar-button-icon fa fa-lg fa-sticky-note"></i>
      
      <span class="sidebar-button-desc">Notebook</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/tags">
    
      <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
      
      <span class="sidebar-button-desc">Tags</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/archives">
    
      <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
      
      <span class="sidebar-button-desc">Archives</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      

    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://mirage-zero-nine.github.io/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      

      <div id="main" data-behavior="2"
        class="
               hasCoverMetaOut
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
            <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      LC 94 98 700 1214 1305 1382 1522 - Tree Traversal: Inorder
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2020-07-24T00:00:00Z">
        
  July 24, 2020

      </time>
    
    
  
  
    <span>in</span>
    
      <a class="category-link" href="https://mirage-zero-nine.github.io/categories/tree">Tree</a>, 
    
      <a class="category-link" href="https://mirage-zero-nine.github.io/categories/binary-search-tree">Binary Search Tree</a>, 
    
      <a class="category-link" href="https://mirage-zero-nine.github.io/categories/n-ary-tree">N-Ary Tree</a>
    
  

  </div>

</div>
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <h1 id="table-of-contents">Table of Contents</h1><nav id="TableOfContents">
  <ul>
    <li><a href="#94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal</a>
      <ul>
        <li><a href="#problem-description">Problem Description</a></li>
        <li><a href="#method--code">Method &amp; Code</a></li>
      </ul>
    </li>
    <li><a href="#98-validate-binary-search-tree">98. Validate Binary Search Tree</a>
      <ul>
        <li><a href="#problem-description-1">Problem Description</a></li>
        <li><a href="#method--code-1">Method &amp; Code</a>
          <ul>
            <li><a href="#naive-inorder-traversal">Naive Inorder Traversal</a></li>
            <li><a href="#modified-inorder-traversal">Modified Inorder Traversal</a></li>
            <li><a href="#iterative-approach-with-stack">Iterative Approach With Stack</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#700-search-in-a-binary-search-tree">700. Search in a Binary Search Tree</a>
      <ul>
        <li><a href="#problem-description-2">Problem Description</a></li>
        <li><a href="#method--code-2">Method &amp; Code</a></li>
      </ul>
    </li>
    <li><a href="#1214-two-sum-bsts">1214. Two Sum BSTs</a>
      <ul>
        <li><a href="#problem-description-3">Problem Description</a></li>
        <li><a href="#method--code-3">Method &amp; Code</a></li>
      </ul>
    </li>
    <li><a href="#1305-all-elements-in-two-binary-search-trees">1305. All Elements in Two Binary Search Trees</a>
      <ul>
        <li><a href="#problem-description-4">Problem Description</a></li>
        <li><a href="#method--code-4">Method &amp; Code</a></li>
      </ul>
    </li>
    <li><a href="#1382-balance-a-binary-search-tree">1382. Balance a Binary Search Tree</a>
      <ul>
        <li><a href="#problem-description-5">Problem Description</a></li>
        <li><a href="#method--code-5">Method &amp; Code</a></li>
      </ul>
    </li>
    <li><a href="#1522-diameter-of-n-ary-tree">1522. Diameter of N-Ary Tree</a>
      <ul>
        <li><a href="#problem-description-6">Problem Description</a></li>
        <li><a href="#method--code-6">Method &amp; Code</a></li>
      </ul>
    </li>
  </ul>
</nav>
<h1 id="94-binary-tree-inorder-traversal">94. Binary Tree Inorder Traversal</h1>
<p>Link: <a href="https://leetcode.com/problems/binary-tree-inorder-traversal">Binary Tree Inorder Traversal</a></p>
<h2 id="problem-description">Problem Description</h2>
<p>Given a binary tree, return the <em>inorder</em> traversal of its nodes' values.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
</code></pre><p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>
<h2 id="method--code">Method &amp; Code</h2>
<p>Simply follow the in order traversal rule. Use stack to temporary store node during the process.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Simply follow the in order traversal rule.
</span><span style="color:#75715e"> * Use stack to temporary store node during the process.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node
</span><span style="color:#75715e"> * @return in order traversal node value
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">inorderTraversal</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    LinkedList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> res <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>
    Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
    TreeNode cur <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>

    <span style="color:#75715e">/* Traverse process */</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>cur <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            s<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>cur<span style="color:#f92672">);</span>
            cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        cur <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
        res<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>cur<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
        cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> res<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="98-validate-binary-search-tree">98. Validate Binary Search Tree</h1>
<p>Link: <a href="https://leetcode.com/problems/validate-binary-search-tree/">Validate Binary Search Tree</a></p>
<h2 id="problem-description-1">Problem Description</h2>
<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>
<p>Assume a BST is defined as follows:</p>
<ul>
<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&rsquo;s key.</li>
<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&rsquo;s key.</li>
<li>Both the left and right subtrees must also be binary search trees.</li>
</ul>
<p><strong>Example 1:</strong></p>
<pre><code>    2
   / \
  1   3

Input: [2,1,3]
Output: true
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>    5
   / \
  1   4
     / \
    3   6

Input: [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.
</code></pre><h2 id="method--code-1">Method &amp; Code</h2>
<p>In-order traverse of all nodes in tree will output all nodes in increasing order. Hence, do the in-order traversal in tree and check whether each node follows BST&rsquo;s rule.</p>
<h3 id="naive-inorder-traversal">Naive Inorder Traversal</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * In-order traversal with each root&#39;s value. Compare left subtree and right subtree.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of tree
</span><span style="color:#75715e"> * @return if given tree is a valid BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isValidBST</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">,</span> Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">);</span>     <span style="color:#75715e">// avoid int overflow
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * In-order traversal that compare root&#39;s value to left and right.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root current root
</span><span style="color:#75715e"> * @param min  min value
</span><span style="color:#75715e"> * @param max  max value
</span><span style="color:#75715e"> * @return if given tree is a valid BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> min<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span> max<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&gt;=</span> max <span style="color:#f92672">||</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;=</span> min<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>       <span style="color:#75715e">// no duplicate node as well
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> min<span style="color:#f92672">,</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">,</span> max<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="modified-inorder-traversal">Modified Inorder Traversal</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Inorder traversal.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of tree
</span><span style="color:#75715e"> * @return if given tree is a valid BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">inOrder</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[]{</span>Long<span style="color:#f92672">.</span><span style="color:#a6e22e">MIN_VALUE</span><span style="color:#f92672">};</span>

    <span style="color:#66d9ef">return</span> dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> arr<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * In order traversal to traverse all nodes.
</span><span style="color:#75715e"> * Inorder traversal can traverse all nodes by increasing order if the tree is a valid BST.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param r        current node
</span><span style="color:#75715e"> * @param previous previous node value
</span><span style="color:#75715e"> * @return if given tree is a valid BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>TreeNode r<span style="color:#f92672">,</span> <span style="color:#66d9ef">long</span><span style="color:#f92672">[]</span> previous<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">boolean</span> out<span style="color:#f92672">;</span>
    out <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>r<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> previous<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span><span style="color:#66d9ef">long</span><span style="color:#f92672">)</span> r<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;=</span> previous<span style="color:#f92672">[</span>0<span style="color:#f92672">])</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    previous<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> r<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">return</span> out <span style="color:#f92672">&amp;</span> dfs<span style="color:#f92672">(</span>r<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> previous<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="iterative-approach-with-stack">Iterative Approach With Stack</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Iterative solution based on in-order traversal and stack.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of tree
</span><span style="color:#75715e"> * @return if given tree is a valid BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">stack</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> stack <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;();</span>
    TreeNode current <span style="color:#f92672">=</span> root<span style="color:#f92672">;</span>
    TreeNode previous <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>stack<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>current <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            stack<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>current<span style="color:#f92672">);</span>
            current <span style="color:#f92672">=</span> current<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            TreeNode p <span style="color:#f92672">=</span> stack<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>previous <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;=</span> previous<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            previous <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
            current <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="700-search-in-a-binary-search-tree">700. Search in a Binary Search Tree</h1>
<p>Link: <a href="https://leetcode.com/problems/search-in-a-binary-search-tree/">Search in a Binary Search Tree</a></p>
<h2 id="problem-description-2">Problem Description</h2>
<p>Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node&rsquo;s value equals the given value. Return the subtree rooted with that node. If such node doesn&rsquo;t exist, you should return NULL.</p>
<p>For example,</p>
<pre><code>Given the tree:
        4
       / \
      2   7
     / \
    1   3

And the value to search: 2
</code></pre><p>You should return this subtree:</p>
<pre><code>      2     
     / \   
    1   3
</code></pre><p>In the example above, if we want to search the value <code>5</code>, since there is no node with value <code>5</code>, we should return <code>NULL</code>.</p>
<p>Note that an empty tree is represented by <code>NULL</code>, therefore you would see the expected output (serialized tree format) as <code>[]</code>, not <code>null</code>.</p>
<h2 id="method--code-2">Method &amp; Code</h2>
<p>Basic DFS with recursion. Utilize the rule of BST.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Basic DFS with recursion. Utilize the rule of BST.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node
</span><span style="color:#75715e"> * @param val  target value
</span><span style="color:#75715e"> * @return subtree rooted with that node, if such node doesn&#39;t exist, you should return NULL
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">searchBST</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">==</span> val<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&gt;</span> val<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> searchBST<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> val<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> searchBST<span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> val<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="1214-two-sum-bsts">1214. Two Sum BSTs</h1>
<p>Link: <a href="https://leetcode.com/problems/two-sum-bsts">Two Sum BSTs</a></p>
<h2 id="problem-description-3">Problem Description</h2>
<p>Given two binary search trees, return <code>True</code> if and only if there is a node in the first tree and a node in the second tree whose values sum up to a given integer <code>target</code>.</p>
<p><strong>Example 1:</strong></p>
<p><strong><img src="../../../img/1368_1_a.png" alt="img"><img src="../../../img/1368_1_b.png" alt="img"></strong></p>
<pre><code>Input: root1 = [2,1,4], root2 = [1,0,3], target = 5
Output: true
Explanation: 2 and 3 sum up to 5.
</code></pre><p><strong>Example 2:</strong></p>
<p><strong><img src="../../../img/1368_2_a.png" alt="img"><img src="../../../img/1368_2_b.png" alt="img"></strong></p>
<pre><code>Input: root1 = [0,-10,10], root2 = [5,1,7,0,2], target = 18
Output: false
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>Each tree has at most <code>5000</code> nodes.</li>
<li><code>-10^9 &lt;= target, node.val &lt;= 10^9</code></li>
</ul>
<h2 id="method--code-3">Method &amp; Code</h2>
<p>Naive approach: do the binary search recursively.</p>
<ul>
<li>Time complexity: <code>O(n * m)</code></li>
<li>Space complexity: <code>O(m + n)</code></li>
</ul>
<p>The other approach is use a hash set to store one BSTâ€™s value and then traverse the other one.</p>
<ul>
<li>Time complexity: <code>O(n + m)</code></li>
<li>Space complexity: <code>O(m + n)</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Naive approach: do the binary search recursively.
</span><span style="color:#75715e"> * Time complexity: O(n * m)
</span><span style="color:#75715e"> * Space complexity: O(m + n)
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root1  first BST
</span><span style="color:#75715e"> * @param root2  second BST
</span><span style="color:#75715e"> * @param target target value
</span><span style="color:#75715e"> * @return if there is a node in the first tree and a node in the second tree that sum up to a given target
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">twoSumBSTs</span><span style="color:#f92672">(</span>TreeNode root1<span style="color:#f92672">,</span> TreeNode root2<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> root2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> tmp <span style="color:#f92672">=</span> root1<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">+</span> root2<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tmp <span style="color:#f92672">==</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tmp <span style="color:#f92672">&gt;</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> twoSumBSTs<span style="color:#f92672">(</span>root1<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> root2<span style="color:#f92672">,</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> twoSumBSTs<span style="color:#f92672">(</span>root1<span style="color:#f92672">,</span> root2<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> target<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> twoSumBSTs<span style="color:#f92672">(</span>root1<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> root2<span style="color:#f92672">,</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> twoSumBSTs<span style="color:#f92672">(</span>root1<span style="color:#f92672">,</span> root2<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> target<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Use hash set to traverse the tree first, then search in second tree.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root1  first BST
</span><span style="color:#75715e"> * @param root2  second BST
</span><span style="color:#75715e"> * @param target target value
</span><span style="color:#75715e"> * @return if there is a node in the first tree and a node in the second tree that sum up to a given target
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hashSet</span><span style="color:#f92672">(</span>TreeNode root1<span style="color:#f92672">,</span> TreeNode root2<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root1 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> root2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    HashSet<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>
    inorder<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> root1<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">return</span> search<span style="color:#f92672">(</span>root2<span style="color:#f92672">,</span> target<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Search two sum target based on given value
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param r2     second BST
</span><span style="color:#75715e"> * @param target target value
</span><span style="color:#75715e"> * @param s      hash set stores previous tree elements
</span><span style="color:#75715e"> * @return if there is a node in the first tree and a node in the second tree that sum up to a given target
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">search</span><span style="color:#f92672">(</span>TreeNode r2<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> target<span style="color:#f92672">,</span> HashSet<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r2 <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">contains</span><span style="color:#f92672">(</span>target <span style="color:#f92672">-</span> r2<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> search<span style="color:#f92672">(</span>r2<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> target<span style="color:#f92672">,</span> s<span style="color:#f92672">)</span> <span style="color:#f92672">||</span> search<span style="color:#f92672">(</span>r2<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> target<span style="color:#f92672">,</span> s<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Inorder traversal to save all nodes.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param s hash set
</span><span style="color:#75715e"> * @param r root of tree
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorder</span><span style="color:#f92672">(</span>HashSet<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> s<span style="color:#f92672">,</span> TreeNode r<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    inorder<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> r<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">);</span>
    s<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>r<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
    inorder<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> r<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="1305-all-elements-in-two-binary-search-trees">1305. All Elements in Two Binary Search Trees</h1>
<p>Link: <a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/">All Elements in Two Binary Search Trees</a></p>
<h2 id="problem-description-4">Problem Description</h2>
<p>Given two binary search trees <code>root1</code> and <code>root2</code>.</p>
<p>Return a list containing <em>all the integers</em> from <em>both trees</em> sorted in <strong>ascending</strong> order.</p>
<p><strong>Example 1:</strong></p>
<pre><code>Input: root1 = [2,1,4], root2 = [1,0,3]
Output: [0,1,1,2,3,4]
</code></pre><p><strong>Example 2:</strong></p>
<pre><code>Input: root1 = [0,-10,10], root2 = [5,1,7,0,2]
Output: [-10,0,0,1,2,5,7,10]
</code></pre><p><strong>Example 3:</strong></p>
<pre><code>Input: root1 = [], root2 = [5,1,7,0,2]
Output: [0,1,2,5,7]
</code></pre><p><strong>Example 4:</strong></p>
<pre><code>Input: root1 = [0,-10,10], root2 = []
Output: [-10,0,10]
</code></pre><p><strong>Example 5:</strong></p>
<pre><code>Input: root1 = [1,null,8], root2 = [8,1]
Output: [1,1,8,8]
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>Each tree has at most <code>5000</code> nodes.</li>
<li>Each node&rsquo;s value is between <code>[-10^5, 10^5]</code>.</li>
</ul>
<h2 id="method--code-4">Method &amp; Code</h2>
<p>Similar to in-order traverse iterator. Use two stacks to store all parent nodes in in-order traverse order. Pop out the smaller one until two stacks are both empty.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * In-order traverse iterator.
</span><span style="color:#75715e"> * Use two stacks to store all parent nodes in in-order traverse order.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root1 first root of tree
</span><span style="color:#75715e"> * @param root2 second root of tree
</span><span style="color:#75715e"> * @return list containing all the integers from both trees sorted in ascending order
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">getAllElements</span><span style="color:#f92672">(</span>TreeNode root1<span style="color:#f92672">,</span> TreeNode root2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> out <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;();</span>

    Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> tmp1 <span style="color:#f92672">=</span> inorder<span style="color:#f92672">(</span>root1<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;()),</span> tmp2 <span style="color:#f92672">=</span> inorder<span style="color:#f92672">(</span>root2<span style="color:#f92672">,</span> <span style="color:#66d9ef">new</span> Stack<span style="color:#f92672">&lt;&gt;());</span>
    TreeNode current<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(!</span>tmp1<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>tmp2<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tmp1<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(!</span>tmp2<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>tmp2<span style="color:#f92672">.</span><span style="color:#a6e22e">peek</span><span style="color:#f92672">().</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;</span> tmp1<span style="color:#f92672">.</span><span style="color:#a6e22e">peek</span><span style="color:#f92672">().</span><span style="color:#a6e22e">val</span><span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            current <span style="color:#f92672">=</span> tmp2<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            out<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
            tmp2 <span style="color:#f92672">=</span> inorder<span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> tmp2<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>tmp2<span style="color:#f92672">.</span><span style="color:#a6e22e">isEmpty</span><span style="color:#f92672">()</span> <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>tmp1<span style="color:#f92672">.</span><span style="color:#a6e22e">peek</span><span style="color:#f92672">().</span><span style="color:#a6e22e">val</span> <span style="color:#f92672">&lt;=</span> tmp2<span style="color:#f92672">.</span><span style="color:#a6e22e">peek</span><span style="color:#f92672">().</span><span style="color:#a6e22e">val</span><span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            current <span style="color:#f92672">=</span> tmp1<span style="color:#f92672">.</span><span style="color:#a6e22e">pop</span><span style="color:#f92672">();</span>
            out<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
            tmp1 <span style="color:#f92672">=</span> inorder<span style="color:#f92672">(</span>current<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> tmp1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> out<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Return a stack contains all nodes in in-order traverse order.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root current root
</span><span style="color:#75715e"> * @param tmp  stack with previous nodes
</span><span style="color:#75715e"> * @return stack contains all nodes in in-order traverse order
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">inorder</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">,</span> Stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">&gt;</span> tmp<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> tmp<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        tmp<span style="color:#f92672">.</span><span style="color:#a6e22e">push</span><span style="color:#f92672">(</span>root<span style="color:#f92672">);</span>
        root <span style="color:#f92672">=</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">return</span> tmp<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="1382-balance-a-binary-search-tree">1382. Balance a Binary Search Tree</h1>
<p>Link: <a href="https://leetcode.com/problems/balance-a-binary-search-tree/">Balance a Binary Search Tree</a></p>
<h2 id="problem-description-5">Problem Description</h2>
<p>Given a binary search tree, return a <strong>balanced</strong> binary search tree with the same node values.</p>
<p>A binary search tree is <em>balanced</em> if and only if the depth of the two subtrees of every node never differ by more than 1.</p>
<p>If there is more than one answer, return any of them.</p>
<p><strong>Example 1:</strong></p>
<p><img src="../../../img/1515_ex1.png" alt="img"></p>
<p><img src="../../../img/1515_ex1_out.png" alt="img"></p>
<pre><code>Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2,null,null] is also correct.
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>The number of nodes in the tree is between <code>1</code> and <code>10^4</code>.</li>
<li>The tree nodes will have distinct values between <code>1</code> and <code>10^5</code>.</li>
</ul>
<h2 id="method--code-5">Method &amp; Code</h2>
<p>Flatten the tree into a array list, then build the tree based on the sorted list. The building process is similar to binary search.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * Flatten the tree into a array list, then build the tree based on the sorted list.
</span><span style="color:#75715e"> * The building process is similar to binary search.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of given BST
</span><span style="color:#75715e"> * @return balanced BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> TreeNode <span style="color:#a6e22e">balanceBST</span><span style="color:#f92672">(</span>TreeNode root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sorted <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>       <span style="color:#75715e">// note that array list is much more faster in this problem
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>0<span style="color:#f92672">};</span>                     <span style="color:#75715e">// avoid currency problem caused by global variable
</span><span style="color:#75715e"></span>
    inorder<span style="color:#f92672">(</span>sorted<span style="color:#f92672">,</span> root<span style="color:#f92672">,</span> count<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">return</span> buildTree<span style="color:#f92672">(</span>sorted<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> count<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Inorder traversal to flatten the BST.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param sorted output list
</span><span style="color:#75715e"> * @param root   current node of tree
</span><span style="color:#75715e"> * @param count  count total nodes in tree
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inorder</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sorted<span style="color:#f92672">,</span> TreeNode root<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> count<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    inorder<span style="color:#f92672">(</span>sorted<span style="color:#f92672">,</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span><span style="color:#f92672">,</span> count<span style="color:#f92672">);</span>
    sorted<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">val</span><span style="color:#f92672">);</span>
    count<span style="color:#f92672">[</span>0<span style="color:#f92672">]++;</span>
    inorder<span style="color:#f92672">(</span>sorted<span style="color:#f92672">,</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span><span style="color:#f92672">,</span> count<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Build new balanced BST based on sorted array.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param sorted sorted array
</span><span style="color:#75715e"> * @param left   lower boundary
</span><span style="color:#75715e"> * @param right  upper boundary
</span><span style="color:#75715e"> * @return balanced BST
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> TreeNode <span style="color:#a6e22e">buildTree</span><span style="color:#f92672">(</span>List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> sorted<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> left<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&gt;</span> right<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">-</span> left<span style="color:#f92672">)</span> <span style="color:#f92672">/</span> 2<span style="color:#f92672">;</span>
    TreeNode root <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> TreeNode<span style="color:#f92672">(</span>sorted<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>mid<span style="color:#f92672">));</span>
    root<span style="color:#f92672">.</span><span style="color:#a6e22e">left</span> <span style="color:#f92672">=</span> buildTree<span style="color:#f92672">(</span>sorted<span style="color:#f92672">,</span> left<span style="color:#f92672">,</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">);</span>
    root<span style="color:#f92672">.</span><span style="color:#a6e22e">right</span> <span style="color:#f92672">=</span> buildTree<span style="color:#f92672">(</span>sorted<span style="color:#f92672">,</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">,</span> right<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">return</span> root<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="1522-diameter-of-n-ary-tree">1522. Diameter of N-Ary Tree</h1>
<p>Link: <a href="https://leetcode.com/problems/diameter-of-n-ary-tree/">Diameter of N-Ary Tree</a></p>
<h2 id="problem-description-6">Problem Description</h2>
<p>Given a <code>root</code> of an <a href="https://leetcode.com/articles/introduction-to-n-ary-trees/">N-ary tree</a>, you need to compute the length of the diameter of the tree.</p>
<p>The diameter of an N-ary tree is the length of the <strong>longest</strong> path between any two nodes in the tree. This path may or may not pass through the root.</p>
<p>(Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value.)</p>
<p><strong>Example 1:</strong></p>
<p><img src="../../../img/sample_2_1897.png" alt="img"></p>
<pre><code>Input: root = [1,null,3,2,4,null,5,6]
Output: 3
Explanation: Diameter is shown in red color.
</code></pre><p><strong>Example 2:</strong></p>
<p><strong><img src="../../../img/sample_1_1897.png" alt="img"></strong></p>
<pre><code>Input: root = [1,null,2,null,3,4,null,5,null,6]
Output: 4
</code></pre><p><strong>Example 3:</strong></p>
<p><img src="../../../img/sample_3_1897.png" alt="img"></p>
<pre><code>Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
Output: 7
</code></pre><p><strong>Constraints:</strong></p>
<ul>
<li>The depth of the n-ary tree is less than or equal to <code>1000</code>.</li>
<li>The total number of nodes is between <code>[0, 10^4]</code>.</li>
</ul>
<h2 id="method--code-6">Method &amp; Code</h2>
<p>The diameter is to find the two longest child path in the tree. DFS to find the two longest paths at each node, which the target length. Return the longest path at current node as the return value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * The diameter is to find the two longest child path in the tree.
</span><span style="color:#75715e"> * DFS to find the two longest paths at each node, which the target length.
</span><span style="color:#75715e"> * Return the longest path at current node as the return value.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root node of tree
</span><span style="color:#75715e"> * @return the length of the diameter of the tree
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">diameter</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* Corner case */</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> max <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>1<span style="color:#f92672">];</span>
    dfs<span style="color:#f92672">(</span>root<span style="color:#f92672">,</span> max<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">return</span> max<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * DFS to find the length of child path.
</span><span style="color:#75715e"> * Note that this approach stops at the leave node of the tree.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * @param root root of current subtree
</span><span style="color:#75715e"> * @param max  max sum of two paths in tree
</span><span style="color:#75715e"> * @return max length of child path in current node
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dfs</span><span style="color:#f92672">(</span>Node root<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> max<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>root<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>       <span style="color:#75715e">// leave node
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    PriorityQueue<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> pq <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> PriorityQueue<span style="color:#f92672">&lt;&gt;();</span>

    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Node child <span style="color:#f92672">:</span> root<span style="color:#f92672">.</span><span style="color:#a6e22e">children</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> depth <span style="color:#f92672">=</span> dfs<span style="color:#f92672">(</span>child<span style="color:#f92672">,</span> max<span style="color:#f92672">);</span>
        pq<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>depth<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>pq<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> 2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>        <span style="color:#75715e">// find the longest two path in tree
</span><span style="color:#75715e"></span>            pq<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> l1 <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">(),</span> l2 <span style="color:#f92672">=</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0 <span style="color:#f92672">?</span> 0 <span style="color:#f92672">:</span> pq<span style="color:#f92672">.</span><span style="color:#a6e22e">poll</span><span style="color:#f92672">();</span>
    max<span style="color:#f92672">[</span>0<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>l1 <span style="color:#f92672">+</span> l2<span style="color:#f92672">,</span> max<span style="color:#f92672">[</span>0<span style="color:#f92672">]);</span>     <span style="color:#75715e">// longest path at current subtree
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>l1<span style="color:#f92672">,</span> l2<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>            <span style="color:#75715e">// longest child path at current node
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div>
              
            </div>
          </div>
          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small">TAGGED IN</span><br/>
                    
  <a class="tag tag--primary tag--small" href="https://mirage-zero-nine.github.io/tags/dfs/">DFS</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2020/07/lc-145-590-226-113-437-298-549-1120-1530-tree-traversal-postorder/" data-tooltip="LC 145 590 226 113 437 298 549 1120 1530 - Tree Traversal: Postorder">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2020/07/lc-1500-design-a-file-sharing-system/" data-tooltip="LC 1500 - Design a File Sharing System">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

            
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 <a href="https://miragespace.me/">BorisMirage</a>. All Rights Reserved
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="2">
        <div class="post-actions-wrap">
  
      <nav >
        <ul class="post-actions post-action-nav">
          
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2020/07/lc-145-590-226-113-437-298-549-1120-1530-tree-traversal-postorder/" data-tooltip="LC 145 590 226 113 437 298 549 1120 1530 - Tree Traversal: Postorder">
              
                  <i class="fa fa-angle-left"></i>
                  <span class="hide-xs hide-sm text-small icon-ml">NEXT</span>
                </a>
            </li>
            <li class="post-action">
              
                <a class="post-action-btn btn btn--default tooltip--top" href="https://mirage-zero-nine.github.io/2020/07/lc-1500-design-a-file-sharing-system/" data-tooltip="LC 1500 - Design a File Sharing System">
              
                  <span class="hide-xs hide-sm text-small icon-mr">PREVIOUS</span>
                  <i class="fa fa-angle-right"></i>
                </a>
            </li>
          
        </ul>
      </nav>
    <ul class="post-actions post-action-share" >
      
        <li class="post-action hide-lg hide-md hide-sm">
          <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
            <i class="fa fa-share-alt"></i>
          </a>
        </li>
        
      
      
      <li class="post-action">
        
          <a class="post-action-btn btn btn--default" href="#table-of-contents">
        
          <i class="fa fa-list"></i>
        </a>
      </li>
    </ul>
  
</div>

      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="2">
  <i id="btn-close-shareoptions" class="fa fa-close"></i>
  <ul class="share-options">
    
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>
    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="https://mirage-zero-nine.github.io/img/avatar.jpg" alt="Author&#39;s picture" />
    
    <h4 id="about-card-name">Notebook</h4>
    
      <div id="about-card-bio">Bingo!</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        Seattle
      </div>
    
  </div>
</div>

    

    
  
    
      <div id="cover" style="background-image:url('https://mirage-zero-nine.github.io/img/bg.jpeg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="https://mirage-zero-nine.github.io/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
  




    
  </body>
</html>

