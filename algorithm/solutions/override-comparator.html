<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Problem Set - Override Heap Comparator | Algorithm</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                Problem Set - Override Heap Comparator
            </h1>
        </div>

        <div class="text-right post-date">
            August 18, 2019
        </div>
        <div class="post-main">
            <p>Links:</p>
            <ul>
                <li><a href='https://leetcode.com/problems/last-stone-weight/'>Last Stone Weight</a></li>
                <li><a href='https://leetcode.com/problems/k-closest-points-to-origin'>K Closest Points to Origin</a>
                </li>
                <li><a href='https://leetcode.com/problems/pour-water/'>Pour Water</a></li>
                <li><a href='https://leetcode.com/problems/campus-bikes/'>Campus Bikes</a></li>
            </ul>
            <h2>Problem description </h2>
            <h3>Last Stone Weight</h3>
            <p>We have a collection of rocks, each rock has a positive integer weight.</p>
            <p>Each turn, we choose the two <strong>heaviest</strong> rocks and smash them together. Suppose the stones
                have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:
            </p>
            <ul>
                <li>If <code>x == y</code>, both stones are totally destroyed;</li>
                <li>If <code>x != y</code>, the stone of weight <code>x</code> is totally destroyed, and the stone of
                    weight <code>y</code>has new weight <code>y-x</code>.
                </li>

            </ul>
            <p>At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones
                left.)</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: [2,7,4,1,8,1]
Output: 1
Explanation:
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of last stone.
</code></pre>
            <p><strong>Note:</strong></p>
            <ol start=''>
                <li><code>1 &lt;= stones.length &lt;= 30</code></li>
                <li><code>1 &lt;= stones[i] &lt;= 1000</code></li>

            </ol>
            <h3>K Closest Points to Origin</h3>
            <p>We have a list of <code>points</code> on the plane. Find the <code>K</code> closest points to the origin
                <code>(0, 0)</code>.</p>
            <p>(Here, the distance between two points on a plane is the Euclidean distance.)</p>
            <p>You may return the answer in any order. The answer is guaranteed to be unique (except for the order that
                it is in.)</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: points = [[1,3],[-2,2]], K = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.
We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: points = [[3,3],[5,-1],[-2,4]], K = 2
Output: [[3,3],[-2,4]]
(The answer [[-2,4],[3,3]] would also be accepted.)
</code></pre>
            <p><strong>Note:</strong></p>
            <ol start=''>
                <li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
                <li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
                <li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>

            </ol>
            <h3>Pour Water</h3>
            <p>We are given an elevation map, <code>heights[i]</code> representing the height of the terrain at that
                index. The width at each index is 1. After <code>V</code> units of water fall at index <code>K</code>,
                how much water is at each index?</p>
            <p>Water first drops at index <code>K</code> and rests on top of the highest terrain or water at that index.
                Then, it flows according to the following rules:</p>
            <p>If the droplet would eventually fall by moving left, then move left.</p>
            <p>Otherwise, if the droplet would eventually fall by moving right, then move right.</p>
            <p>Otherwise, rise at it&#39;s current position.</p>
            <p>Here, &quot;eventually fall&quot; means that the droplet will eventually be at a lower level if it moves
                in that direction. Also, &quot;level&quot; means the height of the terrain plus any water in that
                column.</p>
            <p>We can assume there&#39;s infinitely high terrain on the two sides out of bounds of the array. Also,
                there could not be partial water being spread out evenly on more than 1 grid block - each unit of water
                has to be in exactly one block.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Explanation:
#       #
#       #
##  # ###
#########
 0123456    &lt;- index

The first drop of water lands at index K = 3:

#       #
#   w   #
##  # ###
#########
 0123456

When moving left or right, the water can only move to the same level or a lower level.
(By level, we mean the total height of the terrain plus any water in that column.)
Since moving left will eventually make it fall, it moves left.
(A droplet &quot;made to fall&quot; means go to a lower height than it was at previously.)

#       #
#       #
## w# ###
#########
 0123456

Since moving left will not make it fall, it stays in place.  The next droplet falls:

#       #
#   w   #
## w# ###
#########
 0123456

Since the new droplet moving left will eventually make it fall, it moves left.
Notice that the droplet still preferred to move left,
even though it could move right (and moving right makes it fall quicker.)

#       #
#  w    #
## w# ###
#########
 0123456

#       #
#       #
##ww# ###
#########
 0123456

After those steps, the third droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would eventually make it fall, it moves right.

#       #
#   w   #
##ww# ###
#########
 0123456

#       #
#       #
##ww#w###
#########
 0123456

Finally, the fourth droplet falls.
Since moving left would not eventually make it fall, it tries to move right.
Since moving right would not eventually make it fall, it stays in place:

#       #
#   w   #
##ww#w###
#########
 0123456

The final answer is [2,2,2,3,2,2,2]:

    #
 #######
 #######
 0123456
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: heights = [1,2,3,4], V = 2, K = 2
Output: [2,3,3,4]
Explanation:
The last droplet settles at index 1, since moving further left would not cause it to eventually fall to a lower height.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: heights = [3,1,3], V = 5, K = 1
Output: [4,4,4]
</code></pre>
            <p><strong>Note:</strong></p>
            <ol start=''>
                <li><code>heights</code> will have length in <code>[1, 100]</code> and contain integers in <code>[0,
                    99]</code>.
                </li>
                <li><code>V</code> will be in range <code>[0, 2000]</code>.</li>
                <li><code>K</code> will be in range <code>[0, heights.length - 1]</code>.</li>

            </ol>
            <h3>Campus Bikes</h3>
            <p>On a campus represented as a 2D grid, there are <code>N</code> workers and <code>M</code> bikes, with
                <code>N &lt;= M</code>. Each worker and bike is a 2D coordinate on this grid.</p>
            <p>Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the
                (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that
                worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose
                the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with
                the smallest bike index). We repeat this process until there are no available workers.</p>
            <p>The Manhattan distance between two points <code>p1</code> and <code>p2</code> is <code>Manhattan(p1, p2)
                = |p1.x - p2.x| + |p1.y - p2.y|</code>.</p>
            <p>Return a vector <code>ans</code> of length <code>N</code>, where <code>ans[i]</code> is the index
                (0-indexed) of the bike that the <code>i</code>-th worker is assigned to.</p>
            <p><strong>Example 1:</strong></p>
            <p><img src='../../static/img/1261_example_1_v2.png' alt='img' style="height: auto; width: auto"
                    referrerPolicy='no-referrer'/></p>
            <pre><code>Input: workers = [[0,0],[2,1]], bikes = [[1,2],[3,3]]
Output: [1,0]
Explanation:
Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].
</code></pre>
            <p><strong>Example 2:</strong></p>
            <p><img src='../../static/img/1261_example_2_v2.png' alt='img' style="height: auto; width: auto"
                    referrerPolicy='no-referrer'/></p>
            <pre><code>Input: workers = [[0,0],[1,1],[2,0]], bikes = [[1,0],[2,2],[2,1]]
Output: [0,2,1]
Explanation:
Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].
</code></pre>
            <p><strong>Note:</strong></p>
            <ol start=''>
                <li><code>0 &lt;= workers[i][j], bikes[i][j] &lt; 1000</code></li>
                <li>All worker and bike locations are distinct.</li>
                <li><code>1 &lt;= workers.length &lt;= bikes.length &lt;= 1000</code></li>

            </ol>
            <h2>Method</h2>
            <h3>Last Stone Weight</h3>
            <p>Use a heap to store the stone weight. Each time poll out 2 largest and add result to heap.</p>
            <h3>K Closest Points to Origin</h3>
            <p>Use a heap to store K points.</p>
            <h3>Pour Water</h3>
            <p>Use two heaps to store position. One store from K - 1 to its left, the other one stores from K + 1 to its
                right.</p>
            <p>Priority:</p>
            <ol start=''>
                <li>Height of index</li>
                <li>Position.</li>

            </ol>
            <p>Position is as close as to K as possible, which means left heap keeps right, right heap keeps to
                left.</p>
            <p>Adding water should starts at left part.</p>
            <h3>Campus Bikes</h3>
            <p>Use a heap with modified comparator to store the distance-worker-bike pair.</p>
            <h2>Code</h2>
            <h3>Last Stone Weight</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use a heap to store each result.
 *
 * @param stones given stones
 * @return weight of this stone (or 0 if there are no stones left)
 */
public int lastStoneWeight(int[] stones) {
    PriorityQueue&lt;Integer&gt; h = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());

    for (int stone : stones) {
        h.add(stone);
    }

    while (h.size() &gt;= 2) {
        int a = h.poll();
        int b = h.poll();
        if (a != b) {
            h.add(a - b);
        }
    }

    return (h.size() == 0) ? 0 : h.poll();
}
</code></pre>
            <h3>K Closest Points to Origin</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use a heap to store K points.
 *
 * @param points given points list
 * @param K      K nearest points
 * @return K closest points to the origin (0, 0)
 */
public int[][] kClosest(int[][] points, int K) {

    PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;(K, new Comparator&lt;int[]&gt;() {
        public int compare(int[] a, int[] b) {
            return a[0] - b[0];
        }
    });

    for (int i = 0; i &lt; points.length; i++) {
        q.add(new int[]{(int) Math.pow(points[i][0], 2) + (int) Math.pow(points[i][1], 2), i});
    }

    int[][] out = new int[K][2];

    for (int i = 0; i &lt; K; i++) {
        out[i] = points[q.poll()[1]];
    }
    return out;
}
</code></pre>
            <h3>Pour Water</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use two heaps to store position. One store from K - 1 to its left, the other one stores from K + 1 to its right.
 * The priority is, first, height of index, then the position.
 * Position is as close as to K as possible, which means left heap keeps right, right heap keeps to left.
 * Adding water should starts at left part.
 *
 * @param heights given int array representing the height of the terrain at that index
 * @param V       # of water drops
 * @param K       dropping position
 * @return water in each index after V units of water fall at index K
 */
public int[] pourWater(int[] heights, int V, int K) {

    PriorityQueue&lt;Integer&gt; h1 = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer i1, Integer i2) {
            if (heights[i1] - heights[i2] == 0) {
                return i2 - i1;

            }
            return heights[i1] - heights[i2];
        }
    });

    PriorityQueue&lt;Integer&gt; h2 = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() {
        @Override
        public int compare(Integer i1, Integer i2) {
            if (heights[i1] - heights[i2] == 0) {
                return i1 - i2;

            }
            return heights[i1] - heights[i2];
        }
    });

    int left = K - 1, right = K + 1, index;
    for (int i = 0; i &lt; V; i++) {

        while (left &gt;= 0 &amp;&amp; heights[left] &lt;= heights[left + 1]) {
            h1.add(left--);
        }

        while (right &lt; heights.length &amp;&amp; heights[right] &lt;= heights[right - 1]) {
            h2.add(right++);
        }

        if (!h1.isEmpty() &amp;&amp; heights[h1.peek()] &lt; heights[K]) {      // left first
            index = h1.poll();
            heights[index]++;
            h1.add(index);
        } else if (!h2.isEmpty() &amp;&amp; heights[h2.peek()] &lt; heights[K]) {
            index = h2.poll();
            heights[index]++;
            h2.add(index);
        } else {
            heights[K]++;
        }
    }

    return heights;
}
</code></pre>
            <h3>Campus Bikes</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use a heap with modified comparator to store the distance-worker-bike pair.
 *
 * @param workers given workers array
 * @param bikes   given bikes
 * @return minimum possible sum of Manhattan distances between each worker and their assigned bike
 */
public int[] assignBikes(int[][] workers, int[][] bikes) {

    PriorityQueue&lt;int[]&gt; q = new PriorityQueue&lt;&gt;((a, b) -&gt; {
        int compare = Integer.compare(a[0], b[0]);      // compare distance

        if (compare == 0) {     // if distance is same
            if (a[1] == b[1]) {     // worker has smaller # has higher priority
                return Integer.compare(a[2], b[2]);     // otherwise bike has smaller # has higher priority
            }
            return Integer.compare(a[1], b[1]);
        }
        return compare;
    });

    for (int i = 0; i &lt; workers.length; i++) {
        int[] w = workers[i];

        for (int j = 0; j &lt; bikes.length; j++) {
            int[] b = bikes[j];
            q.add(new int[]{Math.abs(w[0] - b[0]) + Math.abs(w[1] - b[1]), i, j});      // add each worker to each bike&#39;s distance
        }
    }

    int[] out = new int[workers.length];
    Arrays.fill(out, -1);
    Set&lt;Integer&gt; s = new HashSet&lt;&gt;();

    while (s.size() &lt; out.length &amp;&amp; !q.isEmpty()) {

        int[] arr = q.poll();

        if (out[arr[1]] == -1 &amp;&amp; !s.contains(arr[2])) {     // if the worker has not assigned a bike
            out[arr[1]] = arr[2];
            s.add(arr[2]);
        }
    }

    return out;
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!-- Nav bar control -->
<script src="../../static/script/nav-bar.js"></script>
</body>
</html>