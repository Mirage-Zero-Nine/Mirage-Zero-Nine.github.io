<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>LRU & LFU Cache Design | Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">Résumé</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                LRU & LFU Cache Design
            </h1>
        </div>

        <div class="text-right post-date">
            July 05, 2019
        </div>
        <div class="post-main">
            <p><span>Links: </span></p>
            <ul>
                <li><a href='https://leetcode.com/problems/lru-cache'><span>LRU Cache</span></a></li>
                <li><a href='https://leetcode.com/problems/lfu-cache/'><span>LFU Cache</span></a></li>

            </ul>
            <h2><span>Problem description </span></h2>
            <h3><span>LRU Cache</span></h3>
            <p><span>Design and implement a data structure for </span><a
                    href='https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU'><span>Least Recently Used (LRU) cache</span></a><span>. It should support the following operations: </span><code>get</code><span> and </span><code>put</code><span>.</span>
            </p>
            <p><code>get(key)</code><span> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</span>
                <code>put(key, value)</code><span> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</span>
            </p>
            <p>
                <span>The cache is initialized with a </span><strong><span>positive</span></strong><span> capacity.</span>
            </p>
            <p><strong><span>Follow up:</span></strong>
                <span>Could you do both operations in </span><strong><span>O(1)</span></strong><span> time complexity?</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
</code></pre>
            <h3><span>LFU Cache</span></h3>
            <p><span>Design and implement a data structure for </span><a
                    href='https://en.wikipedia.org/wiki/Least_frequently_used'><span>Least Frequently Used (LFU)</span></a><span> cache. It should support the following operations: </span><code>get</code><span> and </span><code>put</code><span>.</span>
            </p>
            <p><code>get(key)</code><span> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</span>
                <code>put(key, value)</code><span> - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least </span><strong><span>recently</span></strong><span> used key would be evicted.</span>
            </p>
            <p><strong><span>Follow up:</span></strong>
                <span>Could you do both operations in </span><strong><span>O(1)</span></strong><span> time complexity?</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
</code></pre>
            <h2><span>Method</span></h2>
            <h3><span>LRU Cache</span></h3>
            <p><span>Basically, use node to store key and value. A hash map in this cache is to store key-node pair for searching key. Node in cache works as a double linked list, which contains previous node and next node. </span>
            </p>
            <p><span>When </span><code><span>put</span></code><span> operation finds a existing key, move corresponding node to top of the list. </span>
            </p>
            <p><span>When put a new pair into cache, first check size to avoid oversize, then add this node to top of list. </span>
            </p>
            <p><span>If cache is oversize, then remove last Cache in double linked list. And remove corresponding key as well.</span>
            </p>
            <h3><span>LFU Cache</span></h3>
            <p><span>Use hash map and linked hash set to store key-value pair and key-frequency pair.</span></p>
            <h2><span>Code</span></h2>
            <h3><span>LRU Cache</span></h3>
            <pre><code class='language-java' lang='java'>public class LRUCache_146 {
    private int capacity;
    private Cache head;
    private Cache end;
    private int c = 0;      // count total cache size
    private HashMap&lt;Integer, Cache&gt; cache = new HashMap&lt;&gt;();

    /**
     * Structure of cache:
     * Basically, use node to store key and value. A hash map in this cache is to store key-node pair for searching key.
     * Cache works as a double linked list, which contains previous Cache and next Cache.
     * When &lt;code&gt;put&lt;/code&gt; operation finds a existing key, move corresponding node to top of the list.
     * When put a new pair into cache, first check size to avoid oversize, then add this node to top of list.
     * If cache is oversize, then remove last Cache in double linked list. And remove corresponding key as well.
     *
     * @param capacity cache capacity
     */
    public LRUCache_146(int capacity) {
        this.capacity = capacity;
        this.head = new Cache();
        head.previous = null;
        this.end = new Cache();
        end.next = null;
        head.next = end;
        end.previous = head;
    }

    /**
     * &lt;code&gt;get&lt;/code&gt; operation. Return -1 if key is not found in cache.
     *
     * @param key requesting key
     * @return corresponding value, or -1.
     */
    public int get(int key) {
        Cache temp = cache.get(key);
        if (temp == null) {
            return -1;
        }
        lastUsed(temp);
        return temp.val;
    }

    /**
     * &lt;code&gt;put&lt;/code&gt; operation, put new key-value pair into cache.
     * If cache is oversize, it will remove Least Recently Used (LRU) Cache store in cache.
     *
     * @param key   new key
     * @param value new value
     */
    public void put(int key, int value) {

        Cache node = cache.get(key);

        if (node == null) {
            Cache add = new Cache();
            add.key = key;
            add.val = value;
            c++;
            if (c &gt; capacity) {
                cache.remove(popEnd().key);
                addNode(add);
                cache.put(key, add);
                c--;
            } else {
                addNode(add);
                cache.put(key, add);
            }
        } else {
            cache.get(key).val = value;
            lastUsed(cache.get(key));
        }
    }

    /**
     * Remove given Cache.
     *
     * @param node given Cache
     */
    private void removeNode(Cache node) {
        Cache pre = node.previous;
        Cache next = node.next;
        pre.next = next;
        next.previous = pre;
    }

    /**
     * Move given node next to head node.
     * Note that this node will be removed.
     *
     * @param node
     */
    private void lastUsed(Cache node) {
        removeNode(node);
        addNode(node);
    }

    /**
     * Add a new Cache next to head.
     *
     * @param node Cache to be moved
     */
    private void addNode(Cache node) {
        node.previous = head;
        node.next = head.next;
        head.next.previous = node;
        head.next = node;
    }

    /**
     * Remove last Cache.
     * Hash map needs to know which key to remove, hence pop node is required.
     *
     * @return pop node
     */
    private Cache popEnd() {
        Cache old = end.previous;
        this.removeNode(old);
        return old;
    }

    /**
     * Definition of Cache.
     * Worked as double linked list.
     */
    class Cache {
        public int key;     // cache key
        public int val;     // value store in cache
        public Cache previous;      // previous cache block pointer
        public Cache next;          // next cache block pointer
    }

    public static void main(String[] args) {
        LRUCache_146 testCache = new LRUCache_146(2);

        testCache.put(1, 1);
        testCache.put(2, 2);
        System.out.println(testCache.get(1));
        testCache.put(3, 3);
        System.out.println(testCache.get(2));
        testCache.put(4, 4);
        System.out.println(testCache.get(1));
        System.out.println(testCache.get(3));
        System.out.println(testCache.get(4));
        System.out.println(testCache);
    }
}
</code></pre>
            <h3><span>LFU Cache</span></h3>
            <pre><code class='language-java' lang='java'>public class LFUCache_460 {
    private HashMap&lt;Integer, Integer&gt; pair;       // store key-value pair
    private HashMap&lt;Integer, Integer&gt; count;      // store frequency as key-count pair
    private HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; frequency;        // determine which to be removed
    private int min = -1;
    private int capacity;

    /**
     * Init the cache.
     *
     * @param capacity cache capacity
     */
    public LFUCache_460(int capacity) {
        this.capacity = capacity;
        this.pair = new HashMap&lt;&gt;();
        this.count = new HashMap&lt;&gt;();
        this.frequency = new HashMap&lt;&gt;();
        this.frequency.put(1, new LinkedHashSet&lt;&gt;());     // first value
    }

    /**
     * &lt;code&gt;get&lt;/code&gt; operation. Return -1 if key is not found in cache.
     * Use a hash map to record the frequency.
     *
     * @param key requesting key
     * @return corresponding value, or -1.
     */
    public int get(int key) {

        if (!this.pair.containsKey(key)) {
            return -1;      // key does not exist
        }
        int f = this.count.get(key);
        this.count.put(key, f + 1);      // update frequency

        /* Update hash map frequency for later eviction policy */
        this.frequency.get(f).remove(key);        // current key&#39;s frequency has updated, recreate key-frequency pair
        if (f == this.min &amp;&amp; this.frequency.get(f).size() == 0) {
            this.min++;      // Update min if min frequency in map has changed
        }
        if (!this.frequency.containsKey(f + 1)) {
            this.frequency.put(f + 1, new LinkedHashSet&lt;&gt;());
        }
        this.frequency.get(f + 1).add(key);

        return this.pair.get(key);
    }

    /**
     * &lt;code&gt;put&lt;/code&gt; operation, put new key-value pair into cache.
     * If cache is oversize, it will remove Least Recently Used (LRU) Cache store in cache.
     *
     * @param key   new key
     * @param value new value
     */
    public void put(int key, int value) {

        if (this.capacity &lt; 1) {
            return;
        }

        if (this.pair.containsKey(key)) {
            this.pair.put(key, value);
            get(key);
            return;
        }
        if (this.pair.size() &gt;= this.capacity) {
            int removeLeast = this.frequency.get(this.min).iterator().next();
            this.frequency.get(this.min).remove(removeLeast);
            this.count.remove(removeLeast);
            this.pair.remove(removeLeast);
        }

        this.pair.put(key, value);
        this.count.put(key, 1);
        this.min = 1;
        this.frequency.get(1).add(key);
    }

    public static void main(String[] args) {
        LFUCache_460 testCache = new LFUCache_460(2);

        testCache.put(1, 1);
        testCache.put(2, 2);
        System.out.println(testCache.get(1));
        testCache.put(3, 3);
        System.out.println(testCache.get(2));
        System.out.println(testCache.get(3));
        testCache.put(4, 4);
        System.out.println(testCache.get(1));
        System.out.println(testCache.get(3));
        System.out.println(testCache.get(4));
        System.out.println(testCache);
    }
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!--        inner script to control nav bar background color        -->

</body>
</html>