<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Word Break / Word Break II | Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../static/css/post-content.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
</head>
<body>

<!--        nav bar     -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>Word Break / Word Break II</h1>
        </div>

        <div class="text-right post-date">
            June 07, 2019
        </div>

        <div class="post-main">
            <p>Links: <a href='https://leetcode.com/problems/word-break'>Word Break</a> / <a
                    href='https://leetcode.com/problems/word-break-ii'>Word Break II</a></p>
            <h2>Problem description </h2>
            <h3>Word Break</h3>
            <p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list
                of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated
                sequence of one or more dictionary words.</p>
            <p><strong>Note:</strong></p>
            <ul>
                <li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
                <li>You may assume the dictionary does not contain duplicate words.</li>

            </ul>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
Output: true
Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
Output: true
Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.
             Note that you are allowed to reuse a dictionary word.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
Output: false
</code></pre>
            <h3>Word Break II</h3>
            <p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list
                of <strong>non-empty</strong> words, add spaces in <em>s</em> to construct a sentence where each word is
                a valid dictionary word. Return all such possible sentences.</p>
            <p><strong>Note:</strong></p>
            <ul>
                <li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
                <li>You may assume the dictionary does not contain duplicate words.</li>

            </ul>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input:
s = &quot;catsanddog&quot;
wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]
Output:
[
  &quot;cats and dog&quot;,
  &quot;cat sand dog&quot;
]
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input:
s = &quot;pineapplepenapple&quot;
wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]
Output:
[
  &quot;pine apple pen apple&quot;,
  &quot;pineapple pen apple&quot;,
  &quot;pine applepen apple&quot;
]
Explanation: Note that you are allowed to reuse a dictionary word.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input:
s = &quot;catsandog&quot;
wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
Output:
[]
</code></pre>
            <h2>Method</h2>
            <h3>Word Break</h3>
            <p>The first thought was DFS, and the code is concise and easy. However, DFS would cause a TLE, since it
                would actually iterate all substring during the iteration. The point of this problem is, a DFS-like
                problem asked to find out existence, can be accomplished by dynamic programming. </p>
            <p>The solution of this problem is use a 1D boolean array <code>dp[]</code>. In the array, if <code>substring(0,i)</code>
                is valid under problem description, then <code>dp[i]</code> is true. </p>
            <p>Therefore, iterate the string from beginning to the end, at each char, traverse from current location to
                string beginning to see if there is a position that <code>dp[j]</code> is true. If found one, then see
                if the <code>substring(0,i)</code> is in dictionary. If so, mark <code>dp[i]</code> as true.</p>
            <h3>Word Break II</h3>
            <p>The difference between this question and last question is that the requirement now became to find all
                sentences made up by words. Therefore, to return a full list of all valid words contain in string,
                backtracking seems a proper way. However, if simply implement backtracking to this problem, it will
                cause a TLE since there is a better way to solve it. </p>
            <p>The solution is using DFS and a hash map to store previous result. The key of hash map is the incoming
                string, and the value is the list that contains the all sentences start with incoming string. And in
                this way, if incoming string is not valid, it can simply return an empty list as result.</p>
            <h2>Code</h2>
            <p><a href='https://leetcode.com/problems/word-break'>Word Break</a></p>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming with 1D boolean array.
 * Iterate the given string.
 * Under each substring in iteration, find a breaking point to spilt both substring exist in dictionary.
 *
 * @param s        given string
 * @param wordDict given dictionary
 * @return if s can be segmented into a space-separated sequence of one or more dictionary words
 */
public boolean wordBreak(String s, List&lt;String&gt; wordDict) {

    /* Corner case */
    if (s.length() == 0 || wordDict.size() == 0) {
        return false;
    }

    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;       // avoid first char is found in dictionary but marked as false

    for (int i = 1; i &lt; dp.length; i++) {       // iter string
        for (int j = i; j &gt; -1; j--) {
            if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[s.length()];
}
</code></pre>
            <p><a href='https://leetcode.com/problems/word-break-ii'>Word Break II</a></p>
            <pre><code class='language-java' lang='java'>/**
 * @param s        given string
 * @param wordDict given word dictionary
 * @return all possible sentences
 */
public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) {

    return backtracking(s, wordDict, new HashMap&lt;&gt;());
}

/**
 * Backtracking with hash map to store previous result.
 * It combined backtracking with dynamic programming to avoid TLE.
 *
 * @param s        string
 * @param wordDict given word dictionary
 * @param m        hash map store previous result
 * @return all possible sentences
 */
private List&lt;String&gt; backtracking(String s, List&lt;String&gt; wordDict, Map&lt;String, List&lt;String&gt;&gt; m) {

    if (m.containsKey(s)) {
        return m.get(s);        // avoid duplication
    }

    List&lt;String&gt; out = new ArrayList&lt;&gt;();

    for (String w : wordDict) {
        if (s.startsWith(w)) {
            if (s.substring(w.length()).length() == 0) {
                out.add(w);     // if it is last word in s
            } else {
                for (String subWord : backtracking(s.substring(w.length()), wordDict, m)) {
                    out.add(w + &quot; &quot; + subWord);     // find all words in substring and add to current result
                }
            }
        }
    }
    m.put(s, out);
    System.out.println(m);
    return out;
}
</code></pre>
        </div>
    </div>
</section>
<!--        inner script to control nav bar        -->

<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>
</body>
</html>