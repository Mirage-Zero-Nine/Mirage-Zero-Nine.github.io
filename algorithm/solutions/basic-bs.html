<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Basic Binary Search Problems | Algorithm</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../../post/index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">Résumé</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>Basic Binary Search Problems</h1>
        </div>

        <div class="text-right post-date">
            June 21, 2019
        </div>

        <div class="post-main">
            <p><span>Links: </span></p>
            <ul>
                <li><a href='https://leetcode.com/problems/binary-tree-inorder-traversal'><span>Binary Tree Inorder Traversal</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/binary-tree-preorder-traversal'><span>Binary Tree Preorder Traversal</span></a><span>/</span><a
                        href='https://leetcode.com/problems/flatten-binary-tree-to-linked-list'><span>Flatten Binary Tree to Linked List</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/binary-tree-postorder-traversal'><span>Binary Tree Postorder Traversal</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/'><span>Binary Tree Paths</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/same-tree/'><span>Same Tree</span></a></li>
                <li><a href='https://leetcode.com/problems/symmetric-tree'><span>Symmetric Tree</span></a></li>
                <li><a href='https://leetcode.com/problems/maximum-depth-of-binary-tree'><span>Maximum Depth of Binary Tree</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/minimum-depth-of-binary-tree/'><span>Minimum Depth of Binary Tree</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/'><span>Convert Sorted Array to Binary Search Tree</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/'><span>Convert Sorted List to Binary Search Tree</span></a>
                </li>
                <li>
                    <a href='https://leetcode.com/problems/balanced-binary-tree/'><span>Balanced Binary Tree</span></a><span> / </span><a
                        href='https://leetcode.com/problems/path-sum/'><span>Path Sum</span></a></li>
                <li><a href='https://leetcode.com/problems/path-sum-ii/'><span>Path Sum II</span></a></li>
                <li>
                    <a href='https://leetcode.com/problems/sum-root-to-leaf-numbers/'><span>Sum Root to Leaf Numbers</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/insert-into-a-binary-search-tree/'><span>Insert into a Binary Search Tree</span></a>
                </li>

            </ul>
            <h2><span>Problem description </span></h2>
            <h3><span>Binary Tree Inorder Traversal</span></h3>
            <p><span>Given a binary tree, return the </span><em><span>inorder</span></em><span> traversal of its nodes&#39; values.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
</code></pre>
            <p><strong><span>Follow up:</span></strong><span> Recursive solution is trivial, could you do it iteratively?</span>
            </p>
            <h3><span>Binary Tree Preorder Traversal</span></h3>
            <p><span>Given a binary tree, return the </span><em><span>preorder</span></em><span> traversal of its nodes&#39; values.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
</code></pre>
            <p><strong><span>Follow up:</span></strong><span> Recursive solution is trivial, could you do it iteratively?</span>
            </p>
            <h3><span>Flatten Binary Tree to Linked List</span></h3>
            <p><span>Given a binary tree, flatten it to a linked list in-place.</span></p>
            <p><span>For example, given the following tree:</span></p>
            <pre><code>    1
   / \
  2   5
 / \   \
3   4   6
</code></pre>
            <p><span>The flattened tree should look like:</span></p>
            <pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre>
            <h3><span>Binary Tree Postorder Traversal</span></h3>
            <p><span>Given a binary tree, return the </span><em><span>postorder</span></em><span> traversal of its nodes&#39; values.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [3,2,1]
</code></pre>
            <p><strong><span>Follow up:</span></strong><span> Recursive solution is trivial, could you do it iteratively?</span>
            </p>
            <h3><span>Binary Tree Paths</span></h3>
            <p><span>Given a binary tree, return all root-to-leaf paths.</span></p>
            <p><strong><span>Note:</span></strong><span> A leaf is a node with no children.</span></p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input:

   1
 /   \
2     3
 \
  5

Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre>
            <h3><span>Same Tree</span></h3>
            <p><span>Given two binary trees, write a function to check if they are the same or not.</span></p>
            <p><span>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</span>
            </p>
            <p><strong><span>Example 1:</span></strong></p>
            <pre><code>Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
</code></pre>
            <p><strong><span>Example 2:</span></strong></p>
            <pre><code>Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
</code></pre>
            <p><strong><span>Example 3:</span></strong></p>
            <pre><code>Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
</code></pre>
            <h3><span>Symmetric Tree</span></h3>
            <p>
                <span>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</span>
            </p>
            <p><span>For example, this binary tree </span><code>[1,2,2,3,4,4,3]</code><span> is symmetric:</span></p>
            <pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
            <p><span> </span></p>
            <p><span>But the following </span><code>[1,2,2,null,3,null,3]</code><span> is not:</span></p>
            <pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre>
            <h3><span>Maximum Depth of Binary Tree</span></h3>
            <p><span>Given a binary tree, find its maximum depth.</span></p>
            <p><span>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</span>
            </p>
            <p><strong><span>Note:</span></strong><span> A leaf is a node with no children.</span></p>
            <p><strong><span>Example:</span></strong></p>
            <p><span>Given binary tree </span><code>[3,9,20,null,null,15,7]</code><span>,</span></p>
            <pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
            <p><span>return its depth = 3.</span></p>
            <h3><span>Minimum Depth of Binary Tree</span></h3>
            <p><span>Given a binary tree, find its minimum depth.</span></p>
            <p><span>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span>
            </p>
            <p><strong><span>Note:</span></strong><span> A leaf is a node with no children.</span></p>
            <p><strong><span>Example:</span></strong></p>
            <p><span>Given binary tree </span><code>[3,9,20,null,null,15,7]</code><span>,</span></p>
            <pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
            <p><span>return its minimum depth = 2.</span></p>
            <h3><span>Convert Sorted Array to Binary Search Tree</span></h3>
            <p>
                <span>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</span>
            </p>
            <p><span>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of </span><em><span>every</span></em><span> node never differ by more than 1.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
            <h3><span>Convert Sorted List to Binary Search Tree</span></h3>
            <p><span>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</span>
            </p>
            <p><span>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of </span><em><span>every</span></em><span> node never differ by more than 1.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
            <h3><span>Balanced Binary Tree</span></h3>
            <p><span>Given a binary tree, determine if it is height-balanced.</span></p>
            <p><span>For this problem, a height-balanced binary tree is defined as:</span></p>
            <blockquote><p>
                <span>a binary tree in which the depth of the two subtrees of </span><em><span>every</span></em><span> node never differ by more than 1.</span>
            </p>
            </blockquote>
            <p><strong><span>Example 1:</span></strong></p>
            <p><span>Given the following tree </span><code>[3,9,20,null,null,15,7]</code><span>:</span></p>
            <pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
            <p><span>Return true.</span></p>
            <p><strong><span>Example 2:</span></strong></p>
            <p><span>Given the following tree </span><code>[1,2,2,3,3,null,null,4,4]</code><span>:</span></p>
            <pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</code></pre>
            <p><span>Return false.</span></p>
            <h3><span>Path Sum</span></h3>
            <p><span>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</span>
            </p>
            <p><strong><span>Note:</span></strong><span> A leaf is a node with no children.</span></p>
            <p><strong><span>Example:</span></strong></p>
            <p><span>Given the below binary tree and </span><code>sum = 22</code><span>,</span></p>
            <pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre>
            <p><span>return true, as there exist a root-to-leaf path </span><code>5-&gt;4-&gt;11-&gt;2</code><span> which sum is 22.</span>
            </p>
            <h3><span>Path Sum II</span></h3>
            <p><span>Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given sum.</span>
            </p>
            <p><strong><span>Note:</span></strong><span> A leaf is a node with no children.</span></p>
            <p><strong><span>Example:</span></strong></p>
            <p><span>Given the below binary tree and </span><code>sum = 22</code><span>,</span></p>
            <pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre>
            <p><span>Return:</span></p>
            <pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre>
            <h3><span>Sum Root to Leaf Numbers</span></h3>
            <p><span>Given a binary tree containing digits from </span><code>0-9</code><span> only, each root-to-leaf path could represent a number.</span>
            </p>
            <p><span>An example is the root-to-leaf path </span><code>1-&gt;2-&gt;3</code><span> which represents the number </span><code>123</code><span>.</span>
            </p>
            <p><span>Find the total sum of all root-to-leaf numbers.</span></p>
            <p><strong><span>Note:</span></strong><span> A leaf is a node with no children.</span></p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
</code></pre>
            <p><strong><span>Example 2:</span></strong></p>
            <pre><code>Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.
The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.
The root-to-leaf path 4-&gt;0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
</code></pre>
            <h3><span>Insert into a Binary Search Tree</span></h3>
            <p><span>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</span>
            </p>
            <p><span>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</span>
            </p>
            <p><span>For example, </span></p>
            <pre><code>Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
</code></pre>
            <p><span>You can return this binary search tree:</span></p>
            <pre><code>         4
       /   \
      2     7
     / \   /
    1   3 5
</code></pre>
            <p><span>This tree is also valid:</span></p>
            <pre><code>         5
       /   \
      2     7
     / \
    1   3
         \
          4
</code></pre>
            <h2><span>Method</span></h2>
            <h3><span>Binary Tree Inorder Traversal</span></h3>
            <p>
                <span>Simply follow the in order traversal rule. Use stack to temporary store node during the process.</span>
            </p>
            <h3><span>Binary Tree Preorder Traversal / Flatten Binary Tree to Linked List</span></h3>
            <p><span>Use a stack to store nodes. Each time push right subtree to stack, then push left subtree. In this way to keep left subtree at top of stack.</span>
            </p>
            <p><span>Flatten Binary Tree to Linked List implement the preorder traversal. Simply push the subtree in preorder traversal order and point the right subtree to current node’s right child will be enough. </span>
            </p>
            <p><span>Do not forget to set </span><code>null</code><span> to left subtree.</span></p>
            <h3><span>Binary Tree Postorder Traversal</span></h3>
            <p><span>Order of preorder traversal is root -&gt; left -&gt; right, and order of postorder traversal is left -&gt; right -&gt; root.</span>
            </p>
            <p><span>Therefore, add node to the head of result list will suffice the postorder traversal.</span></p>
            <h3><span>Binary Tree Paths / Same Tree / Symmetric Tree / Maximum Depth of Binary Tree / Minimum Depth of Binary Tree</span>
            </h3>
            <p><span>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree node. The only difference is that during the traversal, first problem check if two nodes in different tree is the same, second problem check if the child node has same value.</span>
            </p>
            <h3><span>Convert Sorted List to Binary Search Tree</span></h3>
            <p><span>The middle index of array is the root of current tree. Therefore, the whole tree can be constructed by binary search.</span>
            </p>
            <h3><span>Convert Sorted List to Binary Search Tree</span></h3>
            <p><span>The only difference between this problem and previous problem is the the linked list can not directly access the elements inside list by index. </span>
            </p>
            <p>
                <span>Therefore, to locate the root in the list, two pointers are acquired: one </span><code>fast</code><span>, one </span><code>slow</code><span>. </span><code>fast</code><span> will move two nodes forward each time, while </span><code>slow</code><span> will only move one forward. In this way, when </span><code>fast</code><span> reaches the end of list, </span><code>slow</code><span> will be just at the middle of list, which is the root node.</span>
            </p>
            <h3><span>Balanced Binary Tree</span></h3>
            <p><span>Use DFS to traversal tree and return the height of tree. If current is an imbalanced tree, or the sub tree is height-imbalanced, return -1.</span>
            </p>
            <h3><span>Path Sum / Path Sum II</span></h3>
            <p><span>Post-order traversal to find each path from root to leaf, and compare the node value to sum to see if there a path that is equals to given value.</span>
            </p>
            <p><span>Path Sum II is actually a backtracking process. Therefore, add a linked list during the traversal process will suffice the requirement of problem.</span>
            </p>
            <h3><span>Sum Root to Leaf Numbers</span></h3>
            <p><span>DFS traverse all nodes in tree from top to bottom, and then from bottom to top. Each time add total value to final result with power of 10.</span>
            </p>
            <h3><span>Insert into a Binary Search Tree</span></h3>
            <p><span>Insert new node to tree’s correct leaf by binary searching to the end.</span></p>
            <h2><span>Code</span></h2>
            <h3><span>Binary Tree Inorder Traversal</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Simply follow the in order traversal rule.
 * Use stack to temporary store node during the process.
 *
 * @param root root node
 * @return in order traversal node value
 */
public List&lt;Integer&gt; inorderTraversal(TreeNode root) {

    LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();
    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
    TreeNode cur = root;

    /* Traverse process */
    while (cur != null || !s.isEmpty()) {

        while (cur != null) {
            s.add(cur);
            cur = cur.left;
        }

        cur = s.pop();
        res.add(cur.val);
        cur = cur.right;
    }

    return res;
}
</code></pre>
            <h3><span>Binary Tree Preorder Traversal</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Use a stack to store nodes.
 * Each time push right subtree to stack, then push left subtree. In this way to keep left subtree at top of stack.
 *
 * @param root root node of tree
 * @return preorder traversal of tree&#39;s values
 */
public List&lt;Integer&gt; preorderTraversal(TreeNode root) {
    List&lt;Integer&gt; out = new LinkedList&lt;&gt;();

    if (root == null) {
        return out;
    }
    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();

    stack.push(root);

    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node != null) {
            out.add(node.val);
            stack.push(node.right);
            stack.push(node.left);      // keep left at top of stack
        }
    }

    return out;
}
</code></pre>
            <h3><span>Flatten Binary Tree to Linked List</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Preorder traversal.
 * Use a stack to store the left subtree and right subtree for later traversal.
 *
 * @param root root node of tree
 */
public void flatten(TreeNode root) {

    if (root == null) {
        return;
    }
    Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();
    s.push(root);
    while (!s.isEmpty()) {
        TreeNode current = s.pop();
        if (current.right != null) {
            s.push(current.right);
        }
        if (current.left != null) {
            s.push(current.left);       // keep left at top of stack
        }
        current.right = (s.isEmpty()) ? null : s.peek();        // point left subtree to flatten right subtree.
    }
}            current.left = null;

</code></pre>
            <h3><span>Binary Tree Postorder Traversal</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Order of preorder traversal is root -&gt; left -&gt; right, and order of postorder traversal is left -&gt; right -&gt; root.
 * Therefore, add node to the head of result list will suffice the postorder traversal.
 * This is same as reverse list.
 *
 * @param root root node
 * @return postorder traversal of tree&#39;s values
 */
public List&lt;Integer&gt; postorderTraversal(TreeNode root) {
    List&lt;Integer&gt; out = new ArrayList&lt;&gt;();

    /* Corner case */
    if (root == null) {
        return out;
    }

    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();

        if (cur != null) {
            out.add(0, cur.val);        // add current root to the head of list
            stack.push(cur.left);
            stack.push(cur.right);
        }
    }
    return out;
}
</code></pre>
            <h3><span>Binary Tree Paths</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Pre-order traversal.
 *
 * @param root root node
 * @return all path from root to leaf
 */
public List&lt;String&gt; binaryTreePaths(TreeNode root) {
    List&lt;String&gt; output = new ArrayList&lt;&gt;();
    if (root != null) {
        dfs(root, &quot;&quot;, output);
    }
    return output;
}

/**
 * Pre-order traversal.
 *
 * @param n      node
 * @param s      path string
 * @param output all path from root to leaf
 */
private void dfs(TreeNode n, String s, List&lt;String&gt; output) {
    if (n.right == null &amp;&amp; n.left == null) {
        output.add(s + n.val);      // end point
    }

    if (n.left != null) {
        dfs(n.left, s + n.val + &quot;-&gt;&quot;, output);
    }
    if (n.right != null) {
        dfs(n.right, s + n.val + &quot;-&gt;&quot;, output);
    }
}
</code></pre>
            <h3><span>Same Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Any kind of traversal of tree (in-order, post-order, pre-order) will suffice.
 * If sub nodes do not be in same situation (null or not null), return false.
 * If value in tree node is same, continue recursion in sub nodes.
 *
 * @param p TreeNode 1
 * @param q TreeNode 2
 * @return if two trees are same
 */
public boolean isSameTree(TreeNode p, TreeNode q) {

    if (p == null &amp;&amp; q == null) {       // end point
        return true;
    }

    if (p == null || q == null) {       // if given two trees has different child node, return false
        return false;
    }
    if (p.val == q.val) {
        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
    }
    return false;
}
</code></pre>
            <h3><span>Symmetric Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Pre-order traversal.
 *
 * @param root root TreeNode
 * @return if this tree is symmetric
 */
public boolean isSymmetric(TreeNode root) {

    /* Corner case */
    if (root == null) {
        return true;
    }
    if (root.left == null &amp;&amp; root.right == null) {
        return true;
    }
    if (root.left == null || root.right == null) {
        return false;
    }

    if (root.left.val == root.right.val) {
        return isSymmetricTree(root.left, root.right);
    }

    return false;
}

/**
 * Almost same as IsSameTree_100 problem, only simply modified the recursion to compare left node and right node.
 *
 * @param p TreeNode 1
 * @param q TreeNode 2
 * @return if two trees are symmetric
 */
private boolean isSymmetricTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    if (p.val == q.val) {
        return isSymmetricTree(p.left, q.right) &amp;&amp; isSymmetricTree(p.right, q.left);
    }
    return false;
}
</code></pre>
            <h3><span>Maximum Depth of Binary Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS, using pre-order traversal.
 *
 * @param root root node
 * @return max depth.
 */
public int maxDepth(TreeNode root) {

    /* Corner case and end point */
    if (root == null) {
        return 0;
    }

    /* Keep find left sub tree and right sub tree until reaches the end */
    return Integer.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>
            <h3><span>Minimum Depth of Binary Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * In order traversal.
 *
 * @param root root node
 * @return depth
 */
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int l = minDepth(root.left);
    int r = minDepth(root.right);

    return (l == 0 || r == 0) ? l + r + 1 : Math.min(l, r) + 1;
}
</code></pre>
            <h3><span>Convert Sorted Array to Binary Search Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Root of the tree is at the mid of array and sub array.
 *
 * @param nums given num array
 * @return height balanced BST
 */
public TreeNode sortedArrayToBST(int[] nums) {

    /* */
    if (nums.length &lt; 2) {
        return (nums.length == 0 ? null : new TreeNode(nums[0]));
    }

    return builder(nums, 0, nums.length - 1);
}

/**
 * Pre-order traversal.
 *
 * @param num   given num array
 * @param start start index
 * @param end   end index
 * @return root of height balanced BST
 */
private TreeNode builder(int[] num, int start, int end) {

    /* End point */
    if (start &gt; end) {
        return null;
    }

    int mid = (start + end) / 2;

    TreeNode root = new TreeNode(num[mid]);

    root.left = builder(num, start, mid - 1);
    root.right = builder(num, mid + 1, end);
    return root;
}
</code></pre>
            <h3><span>Convert Sorted List to Binary Search Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Linked list can not directly get item by index.
 * Therefore, use two pointers to traverse the linked list
 * When faster one reaches the end of list, slow one will be at root (middle of linked list).
 *
 * @param head head node
 * @return root of height balanced BST
 */
public TreeNode sortedListToBST(ListNode head) {

    /* Corner case */
    if (head == null) {
        return null;
    }

    return builder(head, null);
}

/**
 * Use two pointer to find root node.
 * Fast node moves two time faster than slow node.
 * In this way, if fast node reaches the end, slow node will accurately at the mid of list, which is root.
 *
 * @param head head node
 * @param tail end node
 * @return root of height balanced BST
 */
public TreeNode builder(ListNode head, ListNode tail) {

    ListNode slow = head;       // find root (in the mid of linked list)
    ListNode fast = head;       // two time faster move speed

    if (head == tail) {
        return null;
    }

    while (fast != tail &amp;&amp; fast.next != tail) {
        fast = fast.next.next;      // when fast reaches the end, slow will be at mid of list
        slow = slow.next;           // stop at root
    }

    TreeNode root = new TreeNode(slow.val);
    root.left = builder(head, slow);
    root.right = builder(slow.next, tail);

    return root;
}
</code></pre>
            <h3><span>Balanced Binary Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS traversal.
 *
 * @param root root node
 * @return if given tree is height-balanced
 */
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }

    return dfs(root) != -1;
}

/**
 * DFS traversal. If current tree has a imbalanced tree, return -1.
 * Otherwise return the height difference.
 *
 * @param root root node
 * @return if given tree is height-balanced
 */
private int dfs(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int left = dfs(root.left);
    int right = dfs(root.right);

    if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) {      // left/right/current tree is not height-balanced
        return -1;      // sub tree is not height-balanced
    }

    return Math.max(left, right) + 1;       // depth + 1
}
</code></pre>
            <h3><span>Path Sum</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS Tree traversal.
 *
 * @param root root node
 * @param sum  given sum
 * @return if it has a root-to-leaf path such that sum of all values along the path equals the given sum
 */
public boolean hasPathSum(TreeNode root, int sum) {

    if (root == null) {
        return false;
    }

    if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val) {
        return true;
    }

    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
</code></pre>
            <h3><span>Path Sum II</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS.
 *
 * @param root root tree node
 * @param sum  given sum
 * @return all root-to-leaf paths where each path&#39;s sum equals the given sum
 */
public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if (root == null) {
        return res;
    }
    dfs(root, sum, res, new ArrayList&lt;&gt;());

    return res;
}


/**
 * Running DFS to find all possible path.
 *
 * @param r     current root node
 * @param sum   required sum
 * @param res   path list
 * @param cache temporary path list
 * @return all root-to-leaf paths sum equals the given sum
 */
private List&lt;List&lt;Integer&gt;&gt; dfs(TreeNode r, int sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cache) {

    cache.add(r.val);

    if (r.left == null &amp;&amp; r.right == null &amp;&amp; r.val == sum) {
        res.add(new ArrayList&lt;&gt;(cache));

    } else {
        if (r.left != null) {
            dfs(r.left, sum - r.val, res, cache);
        }
        if (r.right != null) {
            dfs(r.right, sum - r.val, res, cache);
        }
    }

    cache.remove(cache.size() - 1);

    return res;
}
</code></pre>
            <h3><span>Sum Root to Leaf Numbers</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS.
 *
 * @param root root node
 * @return total sum of all root-to-leaf numbers
 */
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}

/**
 * Add each node&#39;s value with 10^n
 *
 * @param r root node
 * @param n power
 * @return total sum of all root-to-leaf numbers
 */
public int dfs(TreeNode r, int n) {

    /* End point */
    if (r == null) {
        return 0;
    }

    if (r.right == null &amp;&amp; r.left == null) {
        return n * 10 + r.val;
    }

    return dfs(r.left, n * 10 + r.val) + dfs(r.right, n * 10 + r.val);
}
</code></pre>
            <h3><span>Insert into a Binary Search Tree</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Insert new node to correct subtree of leaf.
 *
 * @param root root node
 * @param val  value to be insert
 * @return BST with inserted value
 */
public TreeNode insertIntoBST(TreeNode root, int val) {

    /* Corner case and end point */
    if (root == null) {
        return new TreeNode(val);
    }

    if (val &lt; root.val) {
        root.left = insertIntoBST(root.left, val);
    } else if (val &gt; root.val) {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}
</code></pre>
        </div>

    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!--        inner script to control nav bar background color        -->
<script>
    $(function () {
        $(document).scroll(function () {

            let $nav = $("#mainNav");
            $nav.toggleClass("scrolled", $(this).scrollTop() > $nav.height());
        })
    })
</script>
</body>
</html>