<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Best Time to Buy and Sell Stock I/II/III/IV | Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../static/css/post-content.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
</head>
<body>

<!--        nav bar     -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>Best Time to Buy and Sell Stock I/II/III/IV</h1>
        </div>

        <div class="text-right post-date">
            June 09, 2019
        </div>

        <div class="post-main">
            <p>Links: <a href='https://leetcode.com/problems/best-time-to-buy-and-sell-stock'>Best Time to Buy and Sell
                Stock</a> / <a href='https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii'>Best Time to Buy
                and Sell Stock II</a> / <a href='https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii'>Best
                Time to Buy and Sell Stock III</a> / <a
                    href='https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv'>Best Time to Buy and Sell
                Stock IV</a></p>
            <h2>Problem description </h2>
            <h3>Best Time to Buy and Sell Stock</h3>
            <p>Say you have an array for which the ith element is the price of a given stock on day i.</p>
            <p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the
                stock), design an algorithm to find the maximum profit.</p>
            <p>Note that you cannot sell a stock before you buy one.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre>
            <h3>Best Time to Buy and Sell Stock II</h3>
            <p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.
            </p>
            <p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e.,
                buy one and sell one share of the stock multiple times).</p>
            <p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell
                the stock before you buy again).</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre>
            <h3>Best Time to Buy and Sell Stock III</h3>
            <p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.
            </p>
            <p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p>
            <p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell
                the stock before you buy again).</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: [3,3,5,0,0,3,1,4]
Output: 6
Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
             Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
</code></pre>
            <h3>Best Time to Buy and Sell Stock IV</h3>
            <h2>Method</h2>
            <h3>Best Time to Buy and Sell Stock</h3>
            <p>Ignore about the concept of “buy” and “sell”. This question is actually asking about finding each
                increasing subarray. The solution is very simple in this way.</p>
            <h3>Best Time to Buy and Sell Stock II</h3>
            <p>This problem can be solved by greedy approach. However, the description is somehow vague and therefore,
                the directly solution is extremely straightforward: add all positive difference to profit. That’s
                it.</p>
            <p>The difference between this problem and previous problem is that in the previous problem, one
                “transaction” can be done, which suggests that the purpose is to find largest gap between two numbers in
                array. And in this problem, since no limits of “transaction”, the purpose turns to simply find each
                positive gap between adjacent numbers.</p>
            <h3>Best Time to Buy and Sell Stock III</h3>
            <p>Use a state machine to describes the problem statement.</p>
            <p>
                <img src='../../static/img/state-machine.png' alt='state-machine' referrerPolicy='no-referrer'/>
            </p>
            <ul>
                <li>State 0: do nothing or buy stock</li>
                <li>State 1: sell stock or hold purchased stock</li>
                <li>State 2: do nothing or buy stock again</li>
                <li>State 3: sell stock again or do nothing</li>

            </ul>
            <p>Finally, it returns the final state <code>s3</code>. If no purchase happened (no profit), then the state machine
                will directly return -price[0]. Compare the state machine result and return 0 if state machine returns a
                negative value.</p>
            <h3>Best Time to Buy and Sell Stock IV</h3>
            <p>There are two approaches to solve this problem (actually they are same): Dynamic programming and State
                machine. The choice is up to which one is understandable.</p>
            <p>However, to avoid MLE (happens when k and array are extreme large), some corner cases should be fixed
                first. If <code>k &gt; prices.length * 2</code>, then the problem can be converted to Best Time to Buy
                and Sell Stock II. The reason is that in given array, it can at most complete <code>2 * k</code>
                operations since only one action can be done at one time.</p>
            <p><strong>Dynamic programming</strong></p>
            <p>State transition:</p>
            <pre><code>[i, j] = max([i, j - 1], prices[j] - prices[j&#39;] + [i - 1, j&#39;])
i: ith transaction
j: prices[j], index in int array price
j&#39;: in range of [0, j-1]
=&gt; [i, j] = max([i, j - 1], prices[j] + max([i - 1, j&#39;] - prices[j&#39;]))  (efficient for looping)
dp[0, j] = 0
dp[i, 0] = 0
</code></pre>
            <p>The idea is to find out max profit from previous transaction and compare to current operation (buy/sell,
                or do nothing). This is actually same as state machine.</p>
            <p><strong>State machine</strong></p>
            <p>It is same as previous problem, which is actually k=2 if use condition in this problem. The state machine
                has <code>k * 2</code> states, and to store them, use a <code>int[]</code> to store the states and
                update it.</p>
            <h2>Code</h2>
            <h3>Best Time to Buy and Sell Stock</h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming.
 * Similar to max subarray problem.
 *
 * @param prices int array
 * @return max &quot;profit&quot;
 */
public int maxProfit(int[] prices) {

    int max = 0, profit = 0;
    for (int i = 1; i &lt; prices.length; i++) {
        profit = Math.max(0, prices[i] - prices[i - 1] + profit);
        max = Math.max(max, profit);
    }
    return max;
}
</code></pre>
            <h3>Best Time to Buy and Sell Stock II</h3>
            <pre><code class='language-java' lang='java'>/**
 * Ignore this problem.
 *
 * @param prices int arr
 * @return max profit
 */
public int maxProfit(int[] prices) {
    int max = 0;
    for (int i = 1; i &lt; prices.length; i++) {
        max = prices[i] &gt; prices[i - 1] ? max + prices[i] - prices[i - 1] : max;
    }
    return max;
}
</code></pre>
            <h3>Best Time to Buy and Sell Stock III</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use a state machine to describes the problem statement.
 * State 0: do nothing or buy stock
 * State 1: sell stock or hold purchased stock
 * State 2: do nothing or buy stock again
 * State 3: sell stock or do nothing
 * Finally, return the final state s3. If no purchase then it will directly return -price[0].
 * If final result is negative, then return 0.
 *
 * @param prices price int array
 * @return max profit
 */
public int maxProfit(int[] prices) {

    /* Corner case */
    if (prices.length == 0) {
        return 0;
    }

    int s0 = -prices[0], s1 = Integer.MIN_VALUE, s2 = Integer.MIN_VALUE, s3 = Integer.MIN_VALUE;
    for (int i = 1; i &lt; prices.length; i++) {
        s0 = Integer.max(s0, -prices[i]);           // state 0
        s1 = Integer.max(s1, s0 + prices[i]);       // sell stock -&gt; turn to state 1 or do nothing
        s2 = Integer.max(s2, s1 - prices[i]);       // second buy -&gt; turn to state 2 or do nothing
        s3 = Integer.max(s3, s2 + prices[i]);       // final state, sell or do nothing
    }
    return Integer.max(s3, 0);      // if the stock price is monotonically decreasing, return 0
}
</code></pre>
            <h3>Best Time to Buy and Sell Stock IV</h3>
            <p><strong>Dynamic programming</strong></p>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming with table.
 * [i, j] = max([i, j - 1], prices[j] - prices[j&#39;] + [i - 1, j&#39;])
 * i: ith transaction
 * j: prices[j], index in int array price
 * j&#39;: in range of [0, j-1]
 * =&gt; [i, j] = max([i, j - 1], prices[j] + max([i - 1, j&#39;] - prices[j&#39;]))  (efficient for looping)
 * dp[0, j] = 0
 * dp[i, 0] = 0
 *
 * @param k      at most k transactions
 * @param prices int array
 * @return max profit
 */
public int dp(int k, int[] prices) {

    /* Corner case */
    if (prices.length &lt; 2) {
        return 0;
    }

    /* Corner case: compare between current and previous value in array */
    if (k &gt;= prices.length / 2) {       // k is sufficient for comparing each adjacent value in array
        int max = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] - prices[i - 1] &gt; 0) {
                max += prices[i] - prices[i - 1];
            }
        }
        return max;
    }

    int[] r1 = new int[prices.length];
    int[] r2 = new int[prices.length];

    for (int i = 0; i &lt; k + 1; i++) {
        int base = -prices[0];
        for (int j = 0; j &lt; r1.length; j++) {
            r2[j] = Integer.max(r2[j - 1], prices[j] + base);
            base = Integer.max(base, r1[j] - prices[j]);
        }

        /* Reduce memory usage */
        for (int j = 0; j &lt; prices.length; j++) {
            r1[j] = r2[j];
            r2[j] = 0;
        }
    }

    return r2[prices.length - 1];
}
</code></pre>
            <p><strong>State machine</strong></p>
            <pre><code class='language-java' lang='java'>/**
 * Use a state machine to save state.
 * The length of state is 2 * k, since each k representing a buy and sell state.
 *
 * @param k      at most k transactions
 * @param prices given int array
 * @return max profit
 */
public int stateMachine(int k, int[] prices) {

    /* Corner case */
    if (k == 0 || prices.length &lt; 2) {
        return 0;
    }

    if (k &gt;= prices.length / 2) {
        int max = 0;
        for (int i = 1; i &lt; prices.length; i++) {
            if (prices[i] - prices[i - 1] &gt; 0) {
                max += prices[i] - prices[i - 1];
            }
        }
        return max;
    }

    int[] state = new int[k * 2];
    state[0] = -prices[0];
    for (int i = 1; i &lt; state.length; i++) {
        state[i] = Integer.MIN_VALUE;
    }

    for (int i = 1; i &lt; prices.length; i++) {
        for (int j = 0; j &lt; state.length; j++) {

            /* State transition */
            if (j == 0) {
                state[j] = Integer.max(state[j], -prices[i]);
            } else {
                state[j] = Integer.max(state[j], (j % 2 == 0 ? state[j - 1] - prices[i] : state[j - 1] + prices[i]));
            }
        }
    }

    return Integer.max(0, state[state.length - 1]);
}
</code></pre>
        </div>
    </div>
</section>
<!--        inner script to control nav bar        -->

<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>
</body>
</html>