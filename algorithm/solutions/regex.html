<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Regular Expression Matching / Wildcard Matching| Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../static/css/post-content.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>Regular Expression Matching / Wildcard Matching</h1>
        </div>

        <div class="text-right post-date">
            June 06, 2019
        </div>

        <div class="post-main">
            <p><span>Links: </span></p>
            <ul>
                <li><a href='https://leetcode.com/problems/regular-expression-matching'><span>Regular Expression Matching</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/wildcard-matching/'><span>Wildcard Matching</span></a></li>

            </ul>
            <h2><span>Problem description </span></h2>
            <p><strong><span>Regular Expression Matching</span></strong></p>
            <p><span>Given an input string (</span><code>s</code><span>) and a pattern (</span><code>p</code><span>), implement regular expression matching with support for </span><code>&#39;.&#39;</code><span> and </span><code>&#39;*&#39;</code><span>.</span>
            </p>
            <pre><code>&#39;.&#39; Matches any single character.
&#39;*&#39; Matches zero or more of the preceding element.
</code></pre>
            <p><span>The matching should cover the </span><strong><span>entire</span></strong><span> input string (not partial).</span>
            </p>
            <p><strong><span>Note:</span></strong></p>
            <ul>
                <li>
                    <code>s</code><span> could be empty and contains only lowercase letters </span><code>a-z</code><span>.</span>
                </li>
                <li>
                    <code>p</code><span> could be empty and contains only lowercase letters </span><code>a-z</code><span>, and characters like </span><code>.</code><span> or </span><code>*</code><span>.</span>
                </li>

            </ul>
            <p><strong><span>Example 1:</span></strong></p>
            <pre><code>Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
</code></pre>
            <p><strong><span>Example 2:</span></strong></p>
            <pre><code>Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: &#39;*&#39; means zero or more of the precedeng element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.
</code></pre>
            <p><strong><span>Example 3:</span></strong></p>
            <pre><code>Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
</code></pre>
            <p><strong><span>Example 4:</span></strong></p>
            <pre><code>Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.
</code></pre>
            <p><strong><span>Example 5:</span></strong></p>
            <pre><code>Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
</code></pre>
            <p><strong><span>Wildcard Matching</span></strong></p>
            <p><span>Given an input string (</span><code>s</code><span>) and a pattern (</span><code>p</code><span>), implement wildcard pattern matching with support for </span><code>&#39;?&#39;</code><span> and </span><code>&#39;*&#39;</code><span>.</span>
            </p>
            <pre><code>&#39;?&#39; Matches any single character.
&#39;*&#39; Matches any sequence of characters (including the empty sequence).
</code></pre>
            <p><span>The matching should cover the </span><strong><span>entire</span></strong><span> input string (not partial).</span>
            </p>
            <p><strong><span>Note:</span></strong></p>
            <ul>
                <li>
                    <code>s</code><span> could be empty and contains only lowercase letters </span><code>a-z</code><span>.</span>
                </li>
                <li>
                    <code>p</code><span> could be empty and contains only lowercase letters </span><code>a-z</code><span>, and characters like </span><code>?</code><span> or </span><code>*</code><span>.</span>
                </li>

            </ul>
            <p><strong><span>Example 1:</span></strong></p>
            <pre><code>Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
</code></pre>
            <p><strong><span>Example 2:</span></strong></p>
            <pre><code>Input:
s = &quot;aa&quot;
p = &quot;*&quot;
Output: true
Explanation: &#39;*&#39; matches any sequence.
</code></pre>
            <p><strong><span>Example 3:</span></strong></p>
            <pre><code>Input:
s = &quot;cb&quot;
p = &quot;?a&quot;
Output: false
Explanation: &#39;?&#39; matches &#39;c&#39;, but the second letter is &#39;a&#39;, which does not match &#39;b&#39;.
</code></pre>
            <p><strong><span>Example 4:</span></strong></p>
            <pre><code>Input:
s = &quot;adceb&quot;
p = &quot;*a*b&quot;
Output: true
Explanation: The first &#39;*&#39; matches the empty sequence, while the second &#39;*&#39; matches the substring &quot;dce&quot;.
</code></pre>
            <p><strong><span>Example 5:</span></strong></p>
            <pre><code>Input:
s = &quot;acdcb&quot;
p = &quot;a*c?b&quot;
Output: false
</code></pre>
            <h2><span>Method</span></h2>
            <p><strong><span>Regular Expression Matching</span></strong></p>
            <p><span>This is a typical dynamic programming with 2D table problem. The key is to find the state transition formulation.</span>
            </p>
            <p>
                <span>The idea would be to reduce the problem to simple ones. For example, there is a string </span><code>adcebdk</code><span> and pattern </span><code>*a*b?k</code><span>, and we want to compute if there is a match for them: </span><code>D
                = True/False</code><span>. One could notice that it seems to be more simple for short strings and patterns and so it would be logical to relate a match </span><code>D[p_len][s_len]</code><span> with the lengths </span><code>p_len</code><span> and </span><code>s_len</code><span> of input pattern and string correspondingly.</span>
            </p>
            <p><span>There are several conditions for state transition, assuming column of boolean table representing pattern string. Note that boolean table has one more row and column than string, hence, if using string index in iteration, corresponding table index should be index + 1.</span>
            </p>
            <ul>
                <li>
                    <span>First of all, iterate the first row of table, and if </span><code>*</code><span>is met, fill </span><code>dp[0][i+1]</code><span> with value in </span><code>dp[0][i+1]</code><span>. This is for the case of pattern starts with </span><code>.*</code><span>.</span>
                </li>
                <li><span>Then iterating table start from second row and column. </span></li>
                <li>
                    <span>If current char in string and pattern is not matched and none of them are </span><code>.</code><span> or </span><code>*</code><span>, fill false in current table cell. </span>
                </li>
                <li><span>If current char in pattern is </span><code>.</code><span>, then it means matching any char, therefore, fill current table cell with previous cell, which is </span><code>dp[i][j]</code><span>.</span>
                </li>
                <li><span>The same situation happens when pattern and string has same char.</span></li>
                <li><span>If current char in pattern is </span><code>*</code><span>, then there are two conditions. First, if </span><code>p.charAt(j
                    - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) !=
                    &#39;.&#39;</code><span>, then it means this </span><code>*</code><span> can only match previous pattern in 0 time, since previous char in pattern is not match to the char in string. The second condition is the rest situations. In this situation it means char before </span><code>*</code><span> can match more than one time. The </span><code>.</code><span> has same function as two same char.</span>
                </li>
                <li><span>Finally, return </span><code>dp[s.length()][p.length()]</code><span>.</span></li>

            </ul>
            <p><strong><span>Wildcard Matching</span></strong></p>
            <p><span>This problem’s only difference to previous one is the matching field of </span><code>*</code><span>. In this problem, the </span><code>*</code><span> can match any sequence including empty sequence. Therefore, </span><code>*</code><span> is the real wildcard in this problem. If current char in pattern is </span><code>*</code><span>, then </span><code>dp[i
                + 1][j + 1] = dp[i + 1][j] || dp[i][j + 1]</code><span>.</span></p>
            <h2><span>Code</span></h2>
            <h3><span>Regular Expression Matching</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming with 2D table.
 * Conditions:
 * if (p.charAt(j) == s.charAt(i) || p.charAt(j) == &#39;.&#39;) -&gt;  dp[i + 1][j + 1] = dp[i][j]
 * if (p.charAt(j) == &#39;*&#39;):
 * 1. p.charAt(j - 1) != s.charAt(i): match previous char in 0 time
 * 2. p.charAt(j - 1) == s.charAt(i): match either previous char in string or pattern, or match previous char 0 time
 * If either condition is satisfied, return false.
 *
 * @param s string
 * @param p pattern string
 * @return if string is matched to pattern
 */
public boolean isMatch(String s, String p) {

    /* Corner case */
    if (s == null || p == null) {
        return false;
    }

    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
    dp[0][0] = true;

    for (int i = 0; i &lt; p.length(); i++) {
        if (p.charAt(i) == &#39;*&#39; &amp;&amp; dp[0][i - 1]) {       // only p contains &#39;.&#39; or &#39;*&#39;
            dp[0][i + 1] = true;
        }
    }

    for (int i = 0; i &lt; s.length(); i++) {
        for (int j = 0; j &lt; p.length(); j++) {
            if (s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;.&#39;) {
                dp[i + 1][j + 1] = dp[i][j];        // if previous string &amp; pattern is matched, then it matches now
            }

            if (p.charAt(j) == &#39;*&#39;) {
                if (p.charAt(j - 1) != s.charAt(i) &amp;&amp; p.charAt(j - 1) != &#39;.&#39;) {
                    dp[i + 1][j + 1] = dp[i + 1][j - 1];        // match char before &#39;*&#39; pattern
                } else {
                    dp[i + 1][j + 1] = dp[i + 1][j] || dp[i][j + 1] || dp[i + 1][j - 1];        // match either previous string or pattern, or 0 time
                }
            }
        }
    }

    for (boolean[] booleans : dp) {
        System.out.println(Arrays.toString(booleans));
    }
    return dp[s.length()][p.length()];
}
</code></pre>
            <h3><span>Wildcard Matching</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming with 2D table.
 * Conditions:
 * if (p.charAt(j) == s.charAt(i) || p.charAt(j) == &#39;.&#39;) -&gt;  dp[i + 1][j + 1] = dp[i][j]
 * if (p.charAt(j) == &#39;*&#39;): since &#39;*&#39; can match empty string, then directly fill dp[i + 1][j] || dp[i][j + 1]
 * If either condition is satisfied, return false.
 *
 * @param s string
 * @param p pattern string
 * @return if string is matched to pattern
 */
public boolean isMatch(String s, String p) {

    /* Corner case */
    if (s == null || p == null) {
        return false;
    }

    boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
    dp[0][0] = true;        // empty string matches empty string

    for (int i = 0; i &lt; p.length(); i++) {
        if (p.charAt(i) == &#39;*&#39;) {        // only p contains &#39;.&#39; or &#39;*&#39;
            dp[0][i + 1] = true;        // &#39;*&#39; can match empty string
        } else {
            break;
        }
    }

    for (int i = 0; i &lt; s.length(); i++) {
        for (int j = 0; j &lt; p.length(); j++) {
            if (s.charAt(i) == p.charAt(j) || p.charAt(j) == &#39;?&#39;) {
                dp[i + 1][j + 1] = dp[i][j];
            }
            if (p.charAt(j) == &#39;*&#39;) {
                dp[i + 1][j + 1] = dp[i + 1][j] || dp[i][j + 1];
            }
        }
    }

    return dp[s.length()][p.length()];
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!--        inner script to control nav bar become purple        -->
<script>
    $(function () {
        $(document).scroll(function () {

            let $nav = $("#mainNav");
            $nav.toggleClass("scrolled", $(this).scrollTop() > $nav.height());
        })
    })
</script>
</body>
</html>