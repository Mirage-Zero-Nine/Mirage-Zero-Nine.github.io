<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Problem Set: Dynamic Programming With Inner Loop | Algorithm</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                Problem Set: Dynamic Programming With Inner Loop
            </h1>
        </div>

        <div class="text-right post-date">
            August 19, 2019
        </div>
        <div class="post-main">
            <p>Links: </p>
            <ul>
                <li><a href='https://leetcode.com/problems/word-break'>Word Break</a></li>
                <li><a href='https://leetcode.com/problems/maximum-vacation-days/'>Maximum Vacation Days</a></li>
                <li><a href='https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/'>Number of Dice Rolls
                    With Target Sum</a></li>
                <li><a href='https://leetcode.com/problems/combination-sum-iv/'>Combination Sum IV</a></li>
                <li><a href='https://leetcode.com/problems/coin-change/'>Coin Change</a></li>

            </ul>
            <h2>Problem description </h2>
            <h3>Word Break</h3>
            <p>Given a <strong>non-empty</strong> string <em>s</em> and a dictionary <em>wordDict</em> containing a list
                of <strong>non-empty</strong> words, determine if <em>s</em> can be segmented into a space-separated
                sequence of one or more dictionary words.</p>
            <p><strong>Note:</strong></p>
            <ul>
                <li>The same word in the dictionary may be reused multiple times in the segmentation.</li>
                <li>You may assume the dictionary does not contain duplicate words.</li>

            </ul>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
Output: true
Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
Output: true
Explanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;.
             Note that you are allowed to reuse a dictionary word.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
Output: false
</code></pre>
            <h3>Maximum Vacation Days</h3>
            <p>LeetCode wants to give one of its best employees the option to travel among <strong>N</strong> cities to
                collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in
                some particular cities and weeks. Your job is to schedule the traveling to maximize the number of
                vacation days you could take, but there are certain rules and restrictions you need to follow.</p>
            <p><strong>Rules and restrictions:</strong></p>
            <ol start=''>
                <li>You can only travel among <strong>N</strong> cities, represented by indexes from 0 to N-1.
                    Initially, you are in the city indexed 0 on <strong>Monday</strong>.
                </li>
                <li>The cities are connected by flights. The flights are represented as a <strong>N*N</strong> matrix
                    (not necessary symmetrical), called <strong>flights</strong> representing the airline status from
                    the city i to the city j. If there is no flight from the city i to the city j, <strong>flights[i][j]
                        = 0</strong>; Otherwise, <strong>flights[i][j] = 1</strong>. Also, <strong>flights[i][i] =
                        0</strong> for all i.
                </li>
                <li>You totally have <strong>K</strong> weeks (<strong>each week has 7 days</strong>) to travel. You can
                    only take flights at most once <strong>per day</strong>and can only take flights on each week&#39;s
                    <strong>Monday</strong> morning. Since flight time is so short, we don&#39;t consider the impact of
                    flight time.
                </li>
                <li>For each city, you can only have restricted vacation days in different weeks, given an
                    <strong>N*K</strong> matrix called <strong>days</strong> representing this relationship. For the
                    value of <strong>days[i][j]</strong>, it represents the maximum days you could take vacation in the
                    city <strong>i</strong> in the week <strong>j</strong>.
                </li>

            </ol>
            <p>You&#39;re given the <strong>flights</strong> matrix and <strong>days</strong> matrix, and you need to
                output the maximum vacation days you could take during <strong>K</strong> weeks.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]
Output: 12
Explanation:
Ans = 6 + 3 + 3 = 12.

One of the best strategies is:
1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.
(Although you start at city 0, we could also fly to and start at other cities since it is Monday.)
2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.
3rd week : stay at city 2, and play 3 days and work 4 days.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input:flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]
Output: 3
Explanation:
Ans = 1 + 1 + 1 = 3.

Since there is no flights enable you to move to another city, you have to stay at city 0 for the whole 3 weeks.
For each week, you only have one day to play and six days to work.
So the maximum number of vacation days is 3.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input:flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]
Output: 21
Explanation:
Ans = 7 + 7 + 7 = 21

One of the best strategies is:
1st week : stay at city 0, and play 7 days.
2nd week : fly from city 0 to city 1 on Monday, and play 7 days.
3rd week : fly from city 1 to city 2 on Monday, and play 7 days.
</code></pre>
            <p><strong>Note:</strong></p>
            <ol start=''>
                <li><strong>N and K</strong> are positive integers, which are in the range of [1, 100].</li>
                <li>In the matrix <strong>flights</strong>, all the values are integers in the range of [0, 1].</li>
                <li>In the matrix <strong>days</strong>, all the values are integers in the range [0, 7].</li>
                <li>You could stay at a city beyond the number of vacation days, but you should <strong>work</strong> on
                    the extra days, which won&#39;t be counted as vacation days.
                </li>
                <li>If you fly from the city A to the city B and take the vacation on that day, the deduction towards
                    vacation days will count towards the vacation days of city B in that week.
                </li>
                <li>We don&#39;t consider the impact of flight hours towards the calculation of vacation days.</li>

            </ol>
            <h3>Number of Dice Rolls With Target Sum</h3>
            <p>You have <code>d</code> dice, and each die has <code>f</code> faces numbered <code>1, 2, ..., f</code>.
            </p>
            <p>Return the number of possible ways (out of <code>fd</code> total ways) <strong>modulo 10^9 + 7</strong>
                to roll the dice so the sum of the face up numbers equals <code>target</code>.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: d = 1, f = 6, target = 3
Output: 1
Explanation:
You throw one die with 6 faces.  There is only one way to get a sum of 3.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: d = 2, f = 6, target = 7
Output: 6
Explanation:
You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:
1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: d = 2, f = 5, target = 10
Output: 1
Explanation:
You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.
</code></pre>
            <p><strong>Example 4:</strong></p>
            <pre><code>Input: d = 1, f = 2, target = 3
Output: 0
Explanation:
You throw one die with 2 faces.  There is no way to get a sum of 3.
</code></pre>
            <p><strong>Example 5:</strong></p>
            <pre><code>Input: d = 30, f = 30, target = 500
Output: 222616187
Explanation:
The answer must be returned modulo 10^9 + 7.
</code></pre>
            <p><strong>Constraints:</strong></p>
            <ul>
                <li><code>1 &lt;= d, f &lt;= 30</code></li>
                <li><code>1 &lt;= target &lt;= 1000</code></li>

            </ul>
            <h3>Combination Sum IV</h3>
            <p>Given an integer array with all positive numbers and no duplicates, find the number of possible
                combinations that add up to a positive integer target.</p>
            <p><strong>Example:</strong></p>
            <pre><code>nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.
</code></pre>
            <p><strong>Follow up:</strong></p>
            <ul>
                <li>What if negative numbers are allowed in the given array? How does it change the problem?</li>
                <li>What limitation we need to add to the question to allow negative numbers?</li>

            </ul>
            <h3>Coin Change</h3>
            <p>You are given coins of different denominations and a total amount of money <em>amount</em>. Write a
                function to compute the fewest number of coins that you need to make up that amount. If that amount of
                money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: coins = [2], amount = 3
Output: -1
</code></pre>
            <p><strong>Note</strong>:
                You may assume that you have an infinite number of each kind of coin.</p>
            <h2>Method</h2>
            <h3>Word Break</h3>
            <p>The first thought was DFS, and the code is concise and easy. However, DFS would cause a TLE, since it
                would actually iterate all substring during the iteration. The point of this problem is, a DFS-like
                problem asked to find out existence, can be accomplished by dynamic programming. </p>
            <p>The solution of this problem is use a 1D boolean array <code>dp[]</code>. In the array, if <code>substring(0,i)</code>
                is valid under problem description, then <code>dp[i]</code> is true. </p>
            <p>Therefore, iterate the string from beginning to the end, at each char, traverse from current location to
                string beginning to see if there is a position that <code>dp[j]</code> is true. If found one, then see
                if the <code>substring(0,i)</code> is in dictionary. If so, mark <code>dp[i]</code> as true.</p>
            <h3>Maximum Vacation Days</h3>
            <p>Dynamic programming with 2D table.</p>
            <p>State transition:</p>
            <p><code>dp[i][j]</code>: max vacation days one can have from week <code>1</code> to week <code>j</code>,
                and you are in city <code>i</code> in week <code>j</code>.
                <code>dp[i][j]</code> = <code>max(dp[i][j], dp[i&#39;][j - 1] + days[i][j])</code>, where <code>0 &lt;=
                    i&#39; &lt; n</code> (previous city -&gt; current city)</p>
            <p>Initially state: if city 0 can fly to city i, then this city at week 0 has <code>days[i][0]</code>
                vacations.</p>
            <h3>Number of Dice Rolls With Target Sum</h3>
            <p>Dynamic programming. </p>
            <p>State transformation:</p>
            <p>If <code>j &lt;= i * f</code> (target # should at least be # of dices):</p>
            <p><code>dp[i][j] = dp[i][j] + dp[i - 1][j - k]</code>, where <code>k</code> from <code>[1, f]</code> and
                <code>j - k &gt;= 0</code></p>
            <h3>Combination Sum IV</h3>
            <p>This is not a combination problem. This is a dynamic programming problem.</p>
            <p>State transition:</p>
            <p><code>dp[i] = dp[i] + dp[i - nums[j]]</code>, iff <code>i - nums[j] &gt;= 0</code>, and <code>j</code> is
                from <code>0</code> to <code>nums.length()</code>.</p>
            <h3>Coin Change</h3>
            <p>Dynamic programming.</p>
            <p>State transformation: <code>dp[i] = Math.min(dp[i - j] + 1)</code>, if <code>i - coins[k] &gt;= 0 &amp;&amp;
                dp[i - coin] != Integer.MAX_VALUE</code></p>
            <h2>Code</h2>
            <h3>Word Break</h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming with 1D boolean array.
 * Iterate the given string.
 * Under each substring in iteration, find a breaking point to spilt both substring exist in dictionary.
 *
 * @param s        given string
 * @param wordDict given dictionary
 * @return if s can be segmented into a space-separated sequence of one or more dictionary words
 */
public boolean wordBreak(String s, List&lt;String&gt; wordDict) {

    /* Corner case */
    if (s.length() == 0 || wordDict.size() == 0) {
        return false;
    }

    boolean[] dp = new boolean[s.length() + 1];
    dp[0] = true;       // avoid first char is found in dictionary but marked as false

    for (int i = 1; i &lt; dp.length; i++) {       // iter string
        for (int j = i; j &gt; -1; j--) {
            if (dp[j] &amp;&amp; wordDict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }

    return dp[s.length()];
}
</code></pre>
            <h3>Maximum Vacation Days</h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming.
 * The state transition:
 * dp[i][j]: max vacation days one can have from week 1 to week j, and you are in city i in week j.
 * dp[i][j] = max(dp[i][j], dp[i&#39;][j - 1] + days[i][j]), where 0 &lt;= i&#39; &lt; n (previous city -&gt; current city)
 * Initially state: if city 0 can fly to city i, then this city at week 0 has days[i][0] vacations.
 *
 * @param flights flights from the city i to j
 * @param days    city i has vacation days in weeks j
 * @return output the maximum vacation days you could take during K weeks
 */
public int maxVacationDays(int[][] flights, int[][] days) {
    if (flights.length == 0 || days.length == 0) {
        return 0;
    }

    int n = days.length, k = days[0].length;
    int[][] dp = new int[n][k];

    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; k; j++) {
            dp[i][j] = -1;
        }
        if (i != 0 &amp;&amp; flights[0][i] == 1) {
            dp[i][0] = days[i][0];      // init state, if first week can directly fly to this city
        }
    }

    dp[0][0] = days[0][0];

    int max = 0;

    for (int week = 1; week &lt; k; week++) {       // each week

        /*
         * Under each week and search each city pair: depart from city i&#39; to destination city i.
         * If there is a flight from city i&#39; to city i, then count the max days under current pair.
         * If city i is reachable from i&#39;, then dp[i&#39;][j-1] should not be -1. */
        for (int depart = 0; depart &lt; n; depart++) {        // start from each departure city
            for (int destination = 0; destination &lt; n; destination++) {     // end at each destination city
                if (dp[depart][week - 1] != -1 &amp;&amp; ((depart == destination) || (flights[depart][destination] == 1))) {
                    dp[destination][week] = Math.max(dp[destination][week], dp[depart][week - 1] + days[destination][week]);
                }
            }
        }
    }

    for (int i = 0; i &lt; n; i++) {
        max = Math.max(dp[i][k - 1], max);      // find max days from last week&#39;s city
    }

    return max;
}
</code></pre>
            <h3>Number of Dice Rolls With Target Sum</h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming.
 * State transformation:
 * If j &lt;= i * f (target # should at least be # of dices)
 * dp[i][j] = dp[i][j] + dp[i - 1][j - k], where k from [1, f] and j - k &gt;= 0.
 *
 * @param d      # of dices
 * @param f      # of faces
 * @param target target #
 * @return # of possible ways (modulo 10^9 + 7) to roll the dice so the sum of the face up numbers equals target
 */
public int numRollsToTarget(int d, int f, int target) {

    /* Corner case */
    if (d * f &lt; target || target &lt; d) {
        return 0;
    }

    int MOD = 1000000007;
    int[][] dp = new int[d + 1][target + 1];
    dp[0][0] = 1;       // 0 dice sums 0

    for (int i = 1; i &lt;= d; i++) {      // how many possibility can i dices sum up to j;
        for (int j = 1; j &lt;= target; j++) {
            if (j &lt;= i * f) {
                for (int k = 1; k &lt;= f &amp;&amp; k &lt;= j; k++) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD;
                }
            }
        }
    }

    return dp[d][target];
}
</code></pre>
            <h3>Combination Sum IV</h3>
            <pre><code class='language-java' lang='java'>/**
 * This is not a combination problem. This is a dynamic programming problem.
 * State transition:
 * dp[i] = dp[i] + dp[i - nums[j]], iff i - nums[j] &gt;= 0, and j is from 0 to nums.length
 *
 * @param nums   given int array
 * @param target target number
 * @return number of possible combinations that add up to a positive integer target
 */
public int combinationSum4(int[] nums, int target) {

    int[] dp = new int[target + 1];
    dp[0] = 1;

    for (int i = 1; i &lt; dp.length; i++) {
        for (int j = 0; j &lt; nums.length; j++) {
            if (i - nums[j] &gt;= 0) {
                dp[i] += dp[i - nums[j]];
            }
        }
    }

    return dp[target];
}
</code></pre>
            <h3>Coin Change</h3>
            <pre><code class='language-java' lang='java'>/**
 * Dynamic programming.
 * State transformation:
 * dp[i] = Math.min(dp[i - j] + 1), if i - coins[k] &gt;= 0 &amp;&amp; dp[i - coin] != Integer.MAX_VALUE
 *
 * @param coins  given coins list
 * @param amount amount to reach
 * @return fewest number of coins that needed to make up that amount
 */
public int coinChange(int[] coins, int amount) {
    if (coins.length == 0) {
        return -1;
    }
    if (amount == 0) {
        return 0;
    }

    int[] dp = new int[amount + 1];
    Arrays.fill(dp, Integer.MAX_VALUE);     // set init value
    dp[0] = 0;
    for (int i = 1; i &lt; dp.length; i++) {
        for (int coin : coins) {
            if (i - coin &gt;= 0 &amp;&amp; dp[i - coin] != Integer.MAX_VALUE) {
                dp[i] = Math.min(dp[i - coin] + 1, dp[i]);
            }
        }
    }

    return (dp[dp.length - 1] == Integer.MAX_VALUE) ? -1 : dp[dp.length - 1];
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!-- Nav bar control -->
<script src="../../static/script/nav-bar.js"></script>
</body>
</html>