<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Permutation Problems | Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">Résumé</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                Permutation Problems
            </h1>
        </div>

        <div class="text-right post-date">
            July 05, 2019
        </div>
        <div class="post-main">
            <p><span>Links: </span></p>
            <ul>
                <li><a href='https://leetcode.com/problems/next-permutation'><span>Next Permutation</span></a></li>
                <li><a href='https://leetcode.com/problems/permutation-sequence'><span>Permutation Sequence</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/permutations'><span>Permutations</span></a></li>
                <li><a href='https://leetcode.com/problems/permutations-ii/'><span>Permutations II</span></a></li>

            </ul>
            <h2><span>Problem description </span></h2>
            <h3><span>Next Permutation</span></h3>
            <p><span>Implement </span><strong><span>next permutation</span></strong><span>, which rearranges numbers into the lexicographically next greater permutation of numbers.</span>
            </p>
            <p><span>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</span>
            </p>
            <p><span>The replacement must be </span><strong><span>in-place</span></strong><span> and use only constant extra memory.</span>
            </p>
            <p><span>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</span>
            </p>
            <pre><code>1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre>
            <h3><span>Permutation Sequence</span></h3>
            <p>
                <span>The set </span><code>[1,2,3,...,*n*]</code><span> contains a total of </span><em><span>n</span></em><span>! unique permutations.</span>
            </p>
            <p><span>By listing and labeling all of the permutations in order, we get the following sequence for </span><em><span>n</span></em><span> = 3:</span>
            </p>
            <ol start=''>
                <li><code>&quot;123&quot;</code></li>
                <li><code>&quot;132&quot;</code></li>
                <li><code>&quot;213&quot;</code></li>
                <li><code>&quot;231&quot;</code></li>
                <li><code>&quot;312&quot;</code></li>
                <li><code>&quot;321&quot;</code></li>

            </ol>
            <p>
                <span>Given </span><em><span>n</span></em><span> and </span><em><span>k</span></em><span>, return the </span><em><span>k</span></em><span>th permutation sequence.</span>
            </p>
            <p><strong><span>Note:</span></strong></p>
            <ul>
                <li><span>Given </span><em><span>n</span></em><span> will be between 1 and 9 inclusive.</span></li>
                <li>
                    <span>Given </span><em><span>k</span></em><span> will be between 1 and </span><em><span>n</span></em><span>! inclusive.</span>
                </li>

            </ul>
            <p><strong><span>Example 1:</span></strong></p>
            <pre><code>Input: n = 3, k = 3
Output: &quot;213&quot;
</code></pre>
            <p><strong><span>Example 2:</span></strong></p>
            <pre><code>Input: n = 4, k = 9
Output: &quot;2314&quot;
</code></pre>
            <h3><span>Permutations</span></h3>
            <p><span>Given a collection of </span><strong><span>distinct</span></strong><span> integers, return all possible permutations.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
</code></pre>
            <h3><span>Permutations II</span></h3>
            <p><span>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</code></pre>
            <h2><span>Method</span></h2>
            <h3><span>Next Permutation</span></h3>
            <p><span>This problem is actually to find the next larger number based on given number.</span></p>
            <p><span>Start at last digit of number, and find the increasing order of digits from right to left. The increasing order means this sequence is the largest number and no more larger can be found. </span>
            </p>
            <p><span>Find the minimum value in increasing array that is larger than left value next to increasing array. Swap these two elements and reverse the increasing array. </span>
            </p>
            <p><span>The reason of reversing is that, the order of permutation is from small to large. Hence, a new permutation is the smallest value that is larger than current value. </span>
            </p>
            <p><span>For instance, given an array = </span><code>{1,2,3,2,1}</code><span>, swap 2 and 3. Then reverse subarray </span><code>{2,2,1}</code><span>. Finally, result is </span><code>{1,3,1,2,2}</code><span>.</span>
            </p>
            <h3><span>Permutation Sequence</span></h3>
            <p><span>Do not use backtracking in this problem. Backtracking would cause TLE under this problem.</span>
            </p>
            <p><span>The better way to solve this problem is by find out kth permutation sequence directly. In this way to avoid the time consuming for finding all sequence.</span>
            </p>
            <p><span>Use an example to demonstrate the process.</span></p>
            <p><span>Assume </span><code>n=4</code><span>, </span><code>k=10</code><span>. Then all sequence can be presented in this way:</span>
            </p>
            <pre><code>1 -&gt; combine permutations of {2, 3, 4}
2 -&gt; combine permutations of {1, 3, 4}
3 -&gt; combine permutations of {1, 2, 4}
4 -&gt; combine permutations of {1, 2, 3}
</code></pre>
            <p><span>Each permutation has </span><code>(n - 1)!</code><span>, which is fixed. Therefore, first step is to find out first number of tenth permutations. </span><code>3!
                = 6</code><span>, and </span><code>6 &lt;= 10 &lt;= 12</code><span>. Hence, first number is 2.</span>
            </p>
            <p><span>Then the second digit of tenth permutation can be determined in similar way, </span><code>10 - 6 =
                4</code><span>, this is the index of resting permutation. And there are total </span><code>3 * 2 =
                6</code><span> permutations. Therefore the index of second digit is 3. </span></p>
            <p><span>Finally, all digits can be fixed and then the kth permutation can be found. In this example, the result is </span><code>2341</code><span>.</span>
            </p>
            <h3><span>Permutations</span></h3>
            <p><span>Use backtracking to traverse each possibility. The end point of backtracking is when current temporary list reaching the size of given array.</span>
            </p>
            <h3><span>Permutations II</span></h3>
            <p><span>The difference between permute problem is that one boolean array is added during backtracking process. This boolean array is to record if current element is used (for uniqueness).</span>
            </p>
            <h2><span>Code</span></h2>
            <h3><span>Next Permutation</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * This problem is actually to find the next larger number based on given number.
 * Start at last digit of number, and find the increasing order of digits from right to left.
 * The increasing order means this sequence is the largest number and no more larger can be found.
 * Find the minimum value in increasing array that is larger than left value next to increasing array.
 * Swap these two elements and reverse the increasing array.
 * The reason of reversing is that, the order of permutation is from small to large.
 * Hence, a new permutation is the smallest value that is larger than current value.
 * For instance, given a array = {1,2,3,2,1}, swap 2 and 3. Then reverse subarray {2,2,1}.
 * Finally, result is {1,3,1,2,2}.
 *
 * @param nums input int array
 */
public void nextPermutation(int[] nums) {

    /* Corner case */
    if (nums.length &lt; 2) {
        return;
    }

    int i = nums.length - 2;
    while (i &gt; -1 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
        i--;        // find first decreasing (from right to left) value in array
    }

    if (i &gt; -1) {       // if there exist an decreasing element
        int j = nums.length - 1;
        while (j &gt; 0 &amp;&amp; nums[i] &gt;= nums[j]) {
            j--;        // find smallest value in increasing array that is larger than decreasing element
        }
        swap(nums, i, j);       // swap them
    }

    reverse(nums, i + 1, nums.length - 1);
}

/**
 * Swap two elements in array.
 *
 * @param nums given array
 * @param i    first index
 * @param j    second index
 */
private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}

/**
 * Reverse array based on given array and range.
 *
 * @param nums given array
 * @param i    start index
 * @param j    end index
 */
private void reverse(int[] nums, int i, int j) {
    while (i &lt; j) {
        swap(nums, i, j);
        i++;
        j--;
    }
}
</code></pre>
            <h3><span>Permutation Sequence</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * This problem can not be solved in time when using backtracking.
 * Only need to find out kth permutation sequence, hence no need to find all sequence.
 * Assume given n, then each single digit in n contains (n-1)! subsets.
 * Hence, in this way each digit can be recursively found until the length is acquired.
 *
 * @param n between 1 and 9 inclusive
 * @param k between 1 and n! inclusive
 * @return kth permutation sequence
 */
public String getPermutation(int n, int k) {

    /* Create set */
    List&lt;Integer&gt; set = new LinkedList&lt;&gt;();
    for (int i = 1; i &lt; n + 1; i++) {
        set.add(i);
    }

    int[] factorial = new int[n];       // save factorial from 1 to n
    factorial[0] = 1;
    for (int i = 1; i &lt; factorial.length; i++) {
        factorial[i] = i * factorial[i - 1];
    }

    /* Subset index starts from 0 */
    k = k - 1;
    StringBuilder output = new StringBuilder();

    for (int i = n; i &gt; 0; i--) {

        int temp = k / factorial[i - 1];
        k = k % factorial[i - 1];
        output.append(set.get(temp));

        set.remove(temp);       // find digits in subset that do not contains previous selected digit
    }

    return output.toString();
}
</code></pre>
            <h3><span>Permutations</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Use backtracking to traverse each possibility.
 *
 * @param nums input array
 * @return all possible permutations
 */
public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();

    /* Corner case */
    if (nums.length == 0) {
        return res;
    }

    Arrays.sort(nums);
    backtracking(nums, new ArrayList&lt;&gt;(), res);

    return res;
}

/**
 * Backtracking to find all possible permutations.
 * The end point is when current temporary list has reached the size of given array.
 *
 * @param nums  given array
 * @param cache temporary list
 * @param res   output list
 */
private void backtracking(int[] nums, List&lt;Integer&gt; cache, List&lt;List&lt;Integer&gt;&gt; res) {
    if (cache.size() == nums.length) {
        res.add(new ArrayList&lt;&gt;(cache));
    } else {

        /* Traverse elements in array */
        for (int num : nums) {
            if (!cache.contains(num)) {
                cache.add(num);
                backtracking(nums, cache, res);
                cache.remove(cache.size() - 1);
            }
        }
    }
}
</code></pre>
            <h3><span>Permutations II</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Backtracking.
 * The difference between permute problem is that one boolean array is added during backtracking process.
 * This boolean array is to record if current element is used (for uniqueness).
 *
 * @param nums input number collection
 * @return all possible unique permutations
 */
public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if (nums.length == 0) {
        return res;
    }

    Arrays.sort(nums);
    backtracking(nums, new ArrayList&lt;&gt;(), res, new boolean[nums.length]);
    return res;

}

private void backtracking(int[] nums, List&lt;Integer&gt; cache, List&lt;List&lt;Integer&gt;&gt; res, boolean[] use) {

    /* Exit point */
    if (cache.size() == nums.length) {
        res.add(new ArrayList&lt;&gt;(cache));
    } else {
        for (int i = 0; i &lt; nums.length; i++) {

            if (use[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !use[i - 1]) {     // avoid reuse element in array
                continue;
            }

            /* Add element to list and mark current element as used */
            cache.add(nums[i]);
            use[i] = true;
            backtracking(nums, cache, res, use);
            use[i] = false;
            cache.remove(cache.size() - 1);
        }
    }
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!--        inner script to control nav bar background color        -->

</body>
</html>