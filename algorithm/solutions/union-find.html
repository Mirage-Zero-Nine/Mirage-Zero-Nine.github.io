<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Problem Set - Union Find | Algorithm</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">Résumé</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                Problem Set - Union Find
            </h1>
        </div>

        <div class="text-right post-date">
            August 12, 2019
        </div>
        <div class="post-main">
            <p>Links:</p>
            <ul>
                <li><a href='https://leetcode.com/problems/number-of-islands'>Number of Islands</a></li>
                <li><a href='https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/'>Most Stones
                    Removed with Same Row or Column</a></li>
                <li><a href='https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph'>Number
                    of Connected Components in an Undirected Graph</a></li>

            </ul>
            <h2>Problem description </h2>
            <h3>Number of Connected Components in an Undirected Graph</h3>
            <p>Given <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code> and a list of undirected
                edges (each edge is a pair of nodes), write a function to find the number of connected components in an
                undirected graph.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: n = 5 and edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4

Output: 2
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

Output:  1
</code></pre>
            <p><strong>Note:</strong>
                You can assume that no duplicate edges will appear in <code>edges</code>. Since all edges are
                undirected, <code>[0, 1]</code> is the same as <code>[1, 0]</code> and thus will not appear together in
                <code>edges</code>.</p>
            <h3>Number of Islands</h3>
            <p>Given a 2d grid map of <code>&#39;1&#39;</code>s (land) and <code>&#39;0&#39;</code>s (water), count the
                number of islands. An island is surrounded by water and is formed by connecting adjacent lands
                horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input:
11110
11010
11000
00000

Output: 1
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input:
11000
11000
00100
00011

Output: 3
</code></pre>
            <h3>Most Stones Removed with Same Row or Column</h3>
            <p>On a 2D plane, we place stones at some integer coordinate points. Each coordinate point may have at most
                one stone.</p>
            <p>Now, a <em>move</em> consists of removing a stone that shares a column or row with another stone on the
                grid.</p>
            <p>What is the largest possible number of moves we can make?</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
Output: 5
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
Output: 3
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input: stones = [[0,0]]
Output: 0
</code></pre>
            <p><strong>Note:</strong></p>
            <ol start=''>
                <li><code>1 &lt;= stones.length &lt;= 1000</code></li>
                <li><code>0 &lt;= stones[i][j] &lt; 10000</code></li>

            </ol>
            <h2>Method</h2>
            <h3>Number of Connected Components in an Undirected Graph</h3>
            <p>Classic 1D union find problem. The way to solve it is to find the root of each node. </p>
            <p>Assume all nodes are unconnected and the # of unconnected nodes equal to n. If root of node is different,
                then reduce one on # of unconnected nodes. Finally, the # of unconnected nodes is the # of connected
                components.</p>
            <h3>Number of Islands</h3>
            <p>Two approaches: DFS and Union Find.</p>
            <p><strong>DFS</strong></p>
            <p>Start at each cell with ‘1’, then DFS find all nodes that are connected with current node. Flip node’s
                ‘1’ to ‘0’ each time to reduce runtime.</p>
            <p><strong>Union Find</strong></p>
            <p>First find all nodes and mark them all as individual node. The traverse the whole grid, when two nodes
                are both ‘1’, union them and find root of them. If they have same root, then the number of islands
                should be reduced by 1.</p>
            <h3>Most Stones Removed with Same Row or Column</h3>
            <p>Union find. Note that in this problem, it is not union find on stone, it is based on coord, i.e., x and
                y.</p>
            <p>Count total connected island in whole map, the max move is the total # of 1 reduce # of islands.</p>
            <h2>Code</h2>
            <h3>Number of Connected Components in an Undirected Graph</h3>
            <pre><code class='language-java' lang='java'>/**
 * Union find.
 * Initially, consider all nodes as individual nodes.
 * Then traverse all given edges. Union two vertices that connected by edge.
 *
 * @param n     # of nodes
 * @param edges edges connect nodes
 * @return # of connected components in an undirected graph
 */
public int countComponents(int n, int[][] edges) {
    int[] union = new int[n];

    for (int i = 0; i &lt; union.length; i++) {
        union[i] = i;       // count each node as individual node
    }
    for (int[] e : edges) {
        int r1 = find(e[0], union);
        int r2 = find(e[1], union);
        if (r1 != r2) {
            union[r1] = union[r2];      // union two nodes as connected
            n--;
        }
    }
    return n;
}

/**
 * Find operation.
 *
 * @param i   given node
 * @param arr array of union situation
 * @return root of current node
 */
private int find(int i, int[] arr) {
    while (i != arr[i]) {
        arr[i] = arr[arr[i]];       // update root if current node is not root
        i = arr[i];
    }
    return i;
}
</code></pre>
            <h3>Number of Islands</h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS.
 * When reaches a &#39;1&#39; then do DFS start at this point and mark all accessible point as visited.
 * Iterate all cells in grid.
 *
 * @param grid given grid
 * @return number of connected &#39;1&#39;
 */
public int numIslands(char[][] grid) {
    int count = 0;

    /* Corner case */
    if (grid.length &lt; 1) {
        return count;
    }

    for (int i = 0; i &lt; grid.length; i++) {
        for (int j = 0; j &lt; grid[0].length; j++) {

            if (grid[i][j] == &#39;1&#39;) {
                count += 1;
                grid[i][j] = &#39;0&#39;;
                dfs(grid, i, j);
            }
        }
    }
    return count;
}

/**
 * DFS to access all accessible points based on current point.
 *
 * @param grid given grid
 * @param i    coord x
 * @param j    coord y
 */
private void dfs(char[][] grid, int i, int j) {
    int[] direction = {1, -1, 0, 0, 0, 0, 1, -1};
    grid[i][j] = &#39;0&#39;;

    for (int k = 0; k &lt; 4; k++) {

        int nextX = i + direction[k];
        int nextY = j + direction[k + 4];

        if (nextX &gt; -1 &amp;&amp; nextX &lt; grid.length &amp;&amp; nextY &gt; -1 &amp;&amp; nextY &lt; grid[0].length &amp;&amp; grid[nextX][nextY] == &#39;1&#39;) {
            dfs(grid, nextX, nextY);
        }
    }
}

/**
 * Use union find to connect all nodes that are connected and count all islands.
 *
 * @param grid given grid
 * @return number of islands
 */
public int unionFind(char[][] grid) {

    /* Corner case */
    if (grid == null || grid.length == 0 || grid[0].length == 0) {
        return 0;
    }

    int[][] distance = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    UnionFind uf = new UnionFind(grid);
    int rows = grid.length;
    int cols = grid[0].length;
    for (int i = 0; i &lt; rows; i++) {
        for (int j = 0; j &lt; cols; j++) {
            if (grid[i][j] == &#39;1&#39;) {
                for (int[] d : distance) {
                    int x = i + d[0];
                    int y = j + d[1];
                    if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == &#39;1&#39;) {
                        int id1 = i * cols + j;
                        int id2 = x * cols + y;
                        uf.union(id1, id2);
                    }
                }
            }
        }
    }
    return uf.count;
}

/**
 * Union find class specially implemented for this problem.
 */
class UnionFind {
    int[] father;
    int count = 0;

    /**
     * Count father of each node. Initially, father of each node is itself.
     *
     * @param grid given grid
     */
    UnionFind(char[][] grid) {
        father = new int[grid.length * grid[0].length];     // contains all nodes in 2D array
        for (int i = 0; i &lt; grid.length; i++) {
            for (int j = 0; j &lt; grid[0].length; j++) {
                if (grid[i][j] == &#39;1&#39;) {
                    int id = i * grid[0].length + j;
                    father[id] = id;
                    count++;
                }
            }
        }
    }

    /**
     * Union two nodes that are both &#39;1&#39;.
     * If two nodes are connected, then the # of islands reduced by 1.
     *
     * @param node1 first node
     * @param node2 second node
     */
    void union(int node1, int node2) {
        int find1 = find(node1), find2 = find(node2);
        if (find1 != find2) {
            father[find1] = find2;
            count--;
        }
    }

    /**
     * Find root of given node.
     *
     * @param node given node
     * @return root of given node
     */
    int find(int node) {
        if (father[node] == node) {
            return node;
        }
        father[node] = find(father[node]);      // recursively find father
        return father[node];
    }
}
</code></pre>
            <h3>Most Stones Removed with Same Row or Column</h3>
            <pre><code class='language-java' lang='java'>private HashMap&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();
private int count = 0;

/**
 * Union find.
 * Count total connected island in whole map, the max move is the total # of 1 reduce # of islands.
 *
 * @param stones given array stores stone coord
 * @return largest possible number of moves
 */
public int removeStones(int[][] stones) {

    for (int[] stone : stones) {
        union(stone[0], stone[1] + 10000);     // reverse to avoid duplicated coord x and y
    }

    return stones.length - count;
}

/**
 * Find father based on given x.
 *
 * @param x find father of this node
 * @return father of x
 */
private int find(int x) {

    if (m.putIfAbsent(x, x) == null) {      // if current node is not root
        count++;                            // one less island can be found
    }

    if (x != m.get(x)) {
        m.put(x, find(m.get(x)));           // recursively find father, reset father to avoid counting duplication
    }

    return m.get(x);
}

/**
 * Union two nodes.
 *
 * @param id1 first node
 * @param id2 second node
 */
private void union(int id1, int id2) {
    int f1 = find(id1);
    int f2 = find(id2);

    if (f1 != f2) {
        count--;
        m.put(f1, f2);
    }
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!--        inner script to control nav bar background color        -->
<script>
    $(function () {
        $(document).scroll(function () {

            let $nav = $("#mainNav");
            $nav.toggleClass("scrolled", $(this).scrollTop() > $nav.height());
        })
    })
</script>
</body>
</html>