<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Trie Problems | Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">Résumé</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                Trie Problems
            </h1>
        </div>

        <div class="text-right post-date">
            July 03, 2019
        </div>
        <div class="post-main">
            <p><span>Links: </span></p>
            <ul>
                <li><a href='https://leetcode.com/problems/implement-trie-prefix-tree'><span>Implement Trie (Prefix Tree)</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/add-and-search-word-data-structure-design'><span>Add and Search Word - Data structure design</span></a>
                </li>
                <li><a href='https://leetcode.com/problems/word-search-ii'><span>Word Search II</span></a></li>

            </ul>
            <h2><span>Problem description </span></h2>
            <h3><span>Implement Trie (Prefix Tree)</span></h3>
            <p>
                <span>Implement a trie with </span><code>insert</code><span>, </span><code>search</code><span>, and </span><code>startsWith</code><span> methods.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Trie trie = new Trie();

trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // returns true
trie.search(&quot;app&quot;);     // returns false
trie.startsWith(&quot;app&quot;); // returns true
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);     // returns true
</code></pre>
            <p><strong><span>Note:</span></strong></p>
            <ul>
                <li>
                    <span>You may assume that all inputs are consist of lowercase letters </span><code>a-z</code><span>.</span>
                </li>
                <li><span>All inputs are guaranteed to be non-empty strings.</span></li>

            </ul>
            <h3><span>Add and Search Word - Data structure design</span></h3>
            <p><span>Design a data structure that supports the following two operations:</span></p>
            <pre><code>void addWord(word)
bool search(word)
</code></pre>
            <p>
                <span>search(word) can search a literal word or a regular expression string containing only letters </span><code>a-z</code><span> or </span><code>.</code><span>. A </span><code>.</code><span> means it can represent any one letter.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>addWord(&quot;bad&quot;)
addWord(&quot;dad&quot;)
addWord(&quot;mad&quot;)
search(&quot;pad&quot;) -&gt; false
search(&quot;bad&quot;) -&gt; true
search(&quot;.ad&quot;) -&gt; true
search(&quot;b..&quot;) -&gt; true
</code></pre>
            <p><strong><span>Note:</span></strong>
                <span>You may assume that all words are consist of lowercase letters </span><code>a-z</code><span>.</span>
            </p>
            <h3><span>Word Search II</span></h3>
            <p><span>Given a 2D board and a list of words from the dictionary, find all words in the board.</span></p>
            <p><span>Each word must be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</span>
            </p>
            <p><strong><span>Example:</span></strong></p>
            <pre><code>Input:
board = [
  [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],
  [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],
  [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],
  [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]
]
words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]

Output: [&quot;eat&quot;,&quot;oath&quot;]
</code></pre>
            <p><strong><span>Note:</span></strong></p>
            <ol>
                <li><span>All inputs are consist of lowercase letters </span><code>a-z</code><span>.</span></li>
                <li><span>The values of </span><code>words</code><span> are distinct.</span></li>

            </ol>
            <h2><span>Method</span></h2>
            <h3><span>Implement Trie (Prefix Tree)</span></h3>
            <p>
                <span>Use a node structure to store each char in given word. Node of Trie has following attributes:</span>
            </p>
            <ol start=''>
                <li><span>A hash map (or char array) to store children.</span></li>
                <li><span>Get/set value in node.</span></li>
                <li><span>Get/add children.</span></li>
                <li><span>Check/set end flag to mark current node as end of word (to separate it from prefix).</span>
                </li>

            </ol>
            <h3><span>Add and Search Word - Data structure design</span></h3>
            <p>
                <span>Use the Trie designed in last problem. One thing to modify is that the addition of </span><code>.</code><span>. The </span><code>search()</code><span> has to handle the </span><code>.</code><span> problem. </span>
            </p>
            <p><span>If current char is </span><code>.</code><span>, then find all children under current node and do the DFS on it until find all possible combinations.</span>
            </p>
            <p><span>If current char is </span><code>.</code><span> and it is the end of given searching word, find if passing node is end of word. If it is not the end of it, return false. For instance, if a dictionary has a word </span><code>a</code><span>, then search </span><code>a.</code><span> should return false.</span>
            </p>
            <h3><span>Word Search II</span></h3>
            <p><span>Use a simplified trie that store nodes by array instead of hash map to store given words. Search in board to see if board contains words from list.</span>
            </p>
            <h2><span>Code</span></h2>
            <h3><span>Implement Trie (Prefix Tree)</span></h3>
            <pre><code class='language-java' lang='java'>public class Trie {
    private TrieNode root;

    /**
     * Initialize your data structure here.
     */
    public Trie() {
        root = new TrieNode();
    }

    /**
     * Inserts a word into the trie.
     *
     * @param word word to be inserted to trie
     */
    public void insert(String word) {
        TrieNode temp = root;
        for (int i = 0; i &lt; word.length(); i++) {
            if (!temp.containsChild(word.charAt(i))) {
                temp.addChild(word.charAt(i));
            }
            temp = temp.getChild(word.charAt(i));
        }
        temp.setEnd(true);
    }

    /**
     * Returns if the word is in the trie.
     *
     * @param word given word
     * @return if word is in trie
     */
    public boolean search(String word) {
        TrieNode temp = root;
        for (int i = 0; i &lt; word.length(); i++) {
            if (temp.containsChild(word.charAt(i))) {
                temp = temp.getChild(word.charAt(i));
            } else {
                return false;
            }
        }
        return temp.isEnd();
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix.
     *
     * @param prefix given prefix
     * @return if prefix is in trie
     */
    public boolean startsWith(String prefix) {
        TrieNode temp = root;
        for (int i = 0; i &lt; prefix.length(); i++) {
            if (temp.containsChild(prefix.charAt(i))) {
                temp = temp.getChild(prefix.charAt(i));
            } else {
                return false;
            }
        }
        return true;
    }


    /**
     * Nodes in trie.
     */
    class TrieNode {
        char val;       // value of current node
        HashMap&lt;Character, TrieNode&gt; m = new HashMap&lt;&gt;();       // save children of current trie
        boolean end = false;

        /**
         * Initialize.
         */
        TrieNode() {
        }


        /**
         * Set current node&#39;s value.
         *
         * @param val value to be set
         */
        void setVal(char val) {
            this.val = val;
        }

        /**
         * Add child to current node.
         *
         * @param val children value
         */
        void addChild(char val) {
            this.m.put(val, new TrieNode());
            this.m.get(val).setVal(val);
        }

        /**
         * Mark current node as end of word.
         *
         * @param b boolean to be set
         */
        void setEnd(boolean b) {
            this.end = b;
        }

        /**
         * Check if current node is an end of a word.
         *
         * @return true if current node is an end of a word, false otherwise
         */
        boolean isEnd() {
            return this.end;
        }

        /**
         * Return the child based on given value.
         *
         * @param val value of child
         * @return child node
         */
        TrieNode getChild(char val) {
            return m.get(val);
        }

        /**
         * Get value of current node.
         *
         * @return value in current node
         */
        char getVal() {
            return this.val;
        }

        /**
         * Check if given char is contained in current node&#39;s child.
         *
         * @param val given value
         * @return true if given char is in child
         */
        boolean containsChild(char val) {
            return m.containsKey(val);
        }
    }

    public static void main(String[] args) {
        Trie_208 test = new Trie_208();
        test.insert(&quot;app&quot;);
        test.insert(&quot;apple&quot;);
        test.insert(&quot;beer&quot;);
        test.insert(&quot;add&quot;);
        test.insert(&quot;jam&quot;);
        test.insert(&quot;rental&quot;);
        System.out.println(test.search(&quot;app&quot;));
        System.out.println(test.search(&quot;apps&quot;));
        System.out.println(test.startsWith(&quot;beer&quot;));
        test.insert(&quot;app&quot;);
        System.out.println(test.search(&quot;app&quot;));
    }
}
</code></pre>
            <h3><span>Add and Search Word - Data structure design</span></h3>
            <pre><code class='language-java' lang='java'>public class WordDictionary {

    private TrieNode root;

    /**
     * Initialization.
     */
    public WordDictionary() {
        this.root = new TrieNode();
    }

    /**
     * Adds a word into the data structure.
     *
     * @param word given word to be added
     */
    public void addWord(String word) {
        TrieNode temp = root;
        for (int i = 0; i &lt; word.length(); i++) {
            if (!temp.containsChild(word.charAt(i))) {
                temp.addChild(word.charAt(i));
            }
            temp = temp.getChild(word.charAt(i));
        }
        temp.setEnd(true);
    }

    /**
     * Returns if the word is in the data structure.
     * A word could contain the dot character &#39;.&#39; to represent any one letter.
     *
     * @param word given word
     * @return if the word is in dictionary
     */
    public boolean search(String word) {
        return find(word.toCharArray(), 0, root);
    }

    /**
     * @param word  given word in char array
     * @param index current index in word
     * @param n     root node
     * @return if given word can be found in trie
     */
    private boolean find(char[] word, int index, TrieNode n) {

        if (index == word.length) {
            return n.isEnd();

        } else if (word[index] == &#39;.&#39;) {

            List&lt;TrieNode&gt; temp = n.getAllChildren();
            for (TrieNode node : temp) {
                if (find(word, index + 1, node)) {
                    return true;
                }
            }

        } else if (n.containsChild(word[index])) {
            return find(word, index + 1, n.getChild(word[index]));
        }
        return false;
    }


    /**
     * Nodes in trie.
     */
    class TrieNode {
        private char val;       // value of current node
        private HashMap&lt;Character, TrieNode&gt; m = new HashMap&lt;&gt;();       // save children of current trie
        private boolean end = false;

        /**
         * Initialization.
         */
        TrieNode() {
        }

        /**
         * Set current node&#39;s value.
         *
         * @param val value to be set
         */
        void setVal(char val) {
            this.val = val;
        }

        /**
         * Add child to current node.
         *
         * @param val children value
         */
        void addChild(char val) {
            this.m.put(val, new TrieNode());
            this.m.get(val).setVal(val);
        }

        /**
         * Mark current node as end of word.
         *
         * @param b boolean to be set
         */
        void setEnd(boolean b) {
            this.end = b;
        }

        /**
         * Check if current node is an end of a word.
         *
         * @return true if current node is an end of a word, false otherwise
         */
        boolean isEnd() {
            return this.end;
        }

        /**
         * Return the child based on given value.
         *
         * @param val value of child
         * @return child node
         */
        TrieNode getChild(char val) {
            return m.get(val);
        }

        /**
         * Get value of current node.
         *
         * @return value in current node
         */
        char getVal() {
            return this.val;
        }

        /**
         * Check if given char is contained in current node&#39;s child.
         *
         * @param val given value
         * @return true if given char is in child
         */
        boolean containsChild(char val) {
            return m.containsKey(val);
        }

        List&lt;TrieNode&gt; getAllChildren() {
            return new ArrayList&lt;&gt;(m.values());
        }
    }

    public static void main(String[] args) {
        WordDictionary test = new WordDictionary();
        test.addWord(&quot;bad&quot;);
        test.addWord(&quot;dad&quot;);
        test.addWord(&quot;mad&quot;);
        System.out.println(test.search(&quot;bad.&quot;));
        System.out.println(test.search(&quot;b..&quot;));
        System.out.println(test.search(&quot;...&quot;));
        System.out.println(test.search(&quot;bad&quot;));
        System.out.println(test.search(&quot;.ad&quot;));
        System.out.println(test.search(&quot;dap&quot;));

    }
}
</code></pre>
            <h3><span>Word Search II</span></h3>
            <pre><code class='language-java' lang='java'>/**
 * Use a simplified trie that store nodes by array instead of hash map to store given words.
 * Search in board to see if board contains words from list.
 *
 * @param board given board
 * @param words words list
 * @return all words in list
 */
public List&lt;String&gt; findWords(char[][] board, String[] words) {

    List&lt;String&gt; out = new ArrayList&lt;&gt;();
    TrieNode root = trie(words);

    for (int i = 0; i &lt; board.length; i++) {
        for (int j = 0; j &lt; board[0].length; j++) {
            dfs(board, i, j, root, out);
        }
    }

    return out;
}

/**
 * DFS search in board.
 *
 * @param board given board
 * @param i     row
 * @param j     column
 * @param p     trie node
 * @param out   output list
 */
private void dfs(char[][] board, int i, int j, TrieNode p, List&lt;String&gt; out) {
    char c = board[i][j];
    if (c == &#39;#&#39; || p.next[c - &#39;a&#39;] == null) {
        return;
    }
    p = p.next[c - &#39;a&#39;];
    if (p.word != null) {   // found one
        out.add(p.word);
        p.word = null;     // de-duplicate
    }

    board[i][j] = &#39;#&#39;;
    if (i &gt; 0) {
        dfs(board, i - 1, j, p, out);
    }
    if (j &gt; 0) {
        dfs(board, i, j - 1, p, out);
    }
    if (i &lt; board.length - 1) {
        dfs(board, i + 1, j, p, out);
    }
    if (j &lt; board[0].length - 1) {
        dfs(board, i, j + 1, p, out);
    }
    board[i][j] = c;
}

/**
 * Simplified trie constructed by array.
 *
 * @param words given words list
 * @return new trie
 */
private TrieNode trie(String[] words) {
    TrieNode root = new TrieNode();
    for (String w : words) {
        TrieNode p = root;
        for (char c : w.toCharArray()) {
            int i = c - &#39;a&#39;;
            if (p.next[i] == null) p.next[i] = new TrieNode();
            p = p.next[i];
        }
        p.word = w;
    }
    return root;
}

/**
 * Node in trie.
 */
class TrieNode {
    TrieNode[] next = new TrieNode[26];
    String word;
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!--        inner script to control nav bar        -->
<script>
    $(function () {
        $(document).scroll(function () {

            let $nav = $("#mainNav");
            $nav.toggleClass("scrolled", $(this).scrollTop() > $nav.height());
        })
    })
</script>
</body>
</html>