<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Basic Tree DFS Traversal: In-order / Pre-order / Post-order | Posts</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../static/css/post-content.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
</head>
<body>

<!--        nav bar     -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>Basic Tree DFS Traversal: In-order / Pre-order / Post-order</h1>
        </div>

        <div class="text-right post-date">
            June 10, 2019
        </div>

        <div class="post-main">
            <p>Links: </p>
            <ul>
                <li><a href='https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/'>Binary Tree
                    Paths</a></li>
                <li><a href='https://leetcode.com/problems/same-tree/'>Same Tree</a></li>
                <li><a href='https://leetcode.com/problems/symmetric-tree'>Symmetric Tree</a></li>
                <li><a href='https://leetcode.com/problems/maximum-depth-of-binary-tree'>Maximum Depth of Binary
                    Tree</a></li>
                <li><a href='https://leetcode.com/problems/minimum-depth-of-binary-tree/'>Minimum Depth of Binary
                    Tree</a></li>
                <li><a href='https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/'>Convert Sorted
                    Array to Binary Search Tree</a></li>
                <li><a href='https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/'>Convert Sorted
                    List to Binary Search Tree</a></li>
                <li><a href='https://leetcode.com/problems/balanced-binary-tree/'>Balanced Binary Tree</a> / <a
                        href='https://leetcode.com/problems/path-sum/'>Path Sum</a></li>
                <li><a href='https://leetcode.com/problems/path-sum-ii/'>Path Sum II</a></li>
                <li><a href='https://leetcode.com/problems/sum-root-to-leaf-numbers/'>Sum Root to Leaf Numbers</a></li>
                <li><a href='https://leetcode.com/problems/insert-into-a-binary-search-tree/'>Insert into a Binary
                    Search Tree</a></li>

            </ul>
            <h2>Problem description </h2>
            <h3>Binary Tree Paths</h3>
            <p>Given a binary tree, return all root-to-leaf paths.</p>
            <p><strong>Note:</strong> A leaf is a node with no children.</p>
            <p><strong>Example:</strong></p>
            <pre><code>Input:

   1
 /   \
2     3
 \
  5

Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3
</code></pre>
            <h3>Same Tree</h3>
            <p>Given two binary trees, write a function to check if they are the same or not.</p>
            <p>Two binary trees are considered the same if they are structurally identical and the nodes have the same
                value.</p>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
</code></pre>
            <p><strong>Example 3:</strong></p>
            <pre><code>Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
</code></pre>
            <h3>Symmetric Tree</h3>
            <p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
            <p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>
            <pre><code>    1
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre>
            <p></p>
            <p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>
            <pre><code>    1
   / \
  2   2
   \   \
   3    3
</code></pre>
            <h3>Maximum Depth of Binary Tree</h3>
            <p>Given a binary tree, find its maximum depth.</p>
            <p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest
                leaf node.</p>
            <p><strong>Note:</strong> A leaf is a node with no children.</p>
            <p><strong>Example:</strong></p>
            <p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
            <pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
            <p>return its depth = 3.</p>
            <h3>Minimum Depth of Binary Tree</h3>
            <p>Given a binary tree, find its minimum depth.</p>
            <p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest
                leaf node.</p>
            <p><strong>Note:</strong> A leaf is a node with no children.</p>
            <p><strong>Example:</strong></p>
            <p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
            <pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
            <p>return its minimum depth = 2.</p>
            <h3>Convert Sorted Array to Binary Search Tree</h3>
            <p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>
            <p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two
                subtrees of <em>every</em> node never differ by more than 1.</p>
            <p><strong>Example:</strong></p>
            <pre><code>Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
            <h3>Convert Sorted List to Binary Search Tree</h3>
            <p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced
                BST.</p>
            <p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two
                subtrees of <em>every</em> node never differ by more than 1.</p>
            <p><strong>Example:</strong></p>
            <pre><code>Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
</code></pre>
            <h3>Balanced Binary Tree</h3>
            <p>Given a binary tree, determine if it is height-balanced.</p>
            <p>For this problem, a height-balanced binary tree is defined as:</p>
            <blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by
                more than 1.</p>
            </blockquote>
            <p><strong>Example 1:</strong></p>
            <p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p>
            <pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>
            <p>Return true.</p>
            <p><strong>Example 2:</strong></p>
            <p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p>
            <pre><code>       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
</code></pre>
            <p>Return false.</p>
            <h3>Path Sum</h3>
            <p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the
                values along the path equals the given sum.</p>
            <p><strong>Note:</strong> A leaf is a node with no children.</p>
            <p><strong>Example:</strong></p>
            <p>Given the below binary tree and <code>sum = 22</code>,</p>
            <pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre>
            <p>return true, as there exist a root-to-leaf path <code>5-&gt;4-&gt;11-&gt;2</code> which sum is 22.</p>
            <h3>Path Sum II</h3>
            <p>Given a binary tree and a sum, find all root-to-leaf paths where each path&#39;s sum equals the given
                sum.</p>
            <p><strong>Note:</strong> A leaf is a node with no children.</p>
            <p><strong>Example:</strong></p>
            <p>Given the below binary tree and <code>sum = 22</code>,</p>
            <pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
</code></pre>
            <p>Return:</p>
            <pre><code>[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre>
            <h3>Sum Root to Leaf Numbers</h3>
            <p>Given a binary tree containing digits from <code>0-9</code> only, each root-to-leaf path could represent
                a number.</p>
            <p>An example is the root-to-leaf path <code>1-&gt;2-&gt;3</code> which represents the number
                <code>123</code>.</p>
            <p>Find the total sum of all root-to-leaf numbers.</p>
            <p><strong>Note:</strong> A leaf is a node with no children.</p>
            <p><strong>Example:</strong></p>
            <pre><code>Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.
The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.
The root-to-leaf path 4-&gt;0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
</code></pre>
            <h3>Insert into a Binary Search Tree</h3>
            <p>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the
                value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new
                value does not exist in the original BST.</p>
            <p>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after
                insertion. You can return any of them.</p>
            <p>For example, </p>
            <pre><code>Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
</code></pre>
            <p>You can return this binary search tree:</p>
            <pre><code>         4
       /   \
      2     7
     / \   /
    1   3 5
</code></pre>
            <p>This tree is also valid:</p>
            <pre><code>         5
       /   \
      2     7
     / \
    1   3
         \
          4
</code></pre>
            <h2>Method</h2>
            <h3>Binary Tree Paths / Same Tree / Symmetric Tree / Maximum Depth of Binary Tree / Minimum Depth of Binary
                Tree</h3>
            <p>Idea is almost same. Use pre-order traversal to traverse all nodes in tree and compare value inside tree
                node. The only difference is that during the traversal, first problem check if two nodes in different
                tree is the same, second problem check if the child node has same value.</p>
            <h3>Convert Sorted List to Binary Search Tree</h3>
            <p>The middle index of array is the root of current tree. Therefore, the whole tree can be constructed by
                binary search.</p>
            <h3>Convert Sorted List to Binary Search Tree</h3>
            <p>The only difference between this problem and previous problem is the the linked list can not directly
                access the elements inside list by index. </p>
            <p>Therefore, to locate the root in the list, two pointers are acquired: one <code>fast</code>, one <code>slow</code>.
                <code>fast</code> will move two nodes forward each time, while <code>slow</code> will only move one
                forward. In this way, when <code>fast</code> reaches the end of list, <code>slow</code> will be just at
                the middle of list, which is the root node.</p>
            <h3>Balanced Binary Tree</h3>
            <p>Use DFS to traversal tree and return the height of tree. If current is an imbalanced tree, or the sub
                tree is height-imbalanced, return -1.</p>
            <h3>Path Sum / Path Sum II</h3>
            <p>Post-order traversal to find each path from root to leaf, and compare the node value to sum to see if
                there a path that is equals to given value.</p>
            <p>Path Sum II is actually a backtracking process. Therefore, add a linked list during the traversal process
                will suffice the requirement of problem.</p>
            <h3>Sum Root to Leaf Numbers</h3>
            <p>DFS traverse all nodes in tree from top to bottom, and then from bottom to top. Each time add total value
                to final result with power of 10.</p>
            <h3>Insert into a Binary Search Tree</h3>
            <p>Insert new node to tree’s correct leaf by binary searching to the end.</p>
            <h2>Code</h2>
            <h3>Binary Tree Paths</h3>
            <pre><code class='language-java' lang='java'>/**
 * Pre-order traversal.
 *
 * @param root root node
 * @return all path from root to leaf
 */
public List&lt;String&gt; binaryTreePaths(TreeNode root) {
    List&lt;String&gt; output = new ArrayList&lt;&gt;();
    if (root != null) {
        dfs(root, &quot;&quot;, output);
    }
    return output;
}

/**
 * Pre-order traversal.
 *
 * @param n      node
 * @param s      path string
 * @param output all path from root to leaf
 */
private void dfs(TreeNode n, String s, List&lt;String&gt; output) {
    if (n.right == null &amp;&amp; n.left == null) {
        output.add(s + n.val);      // end point
    }

    if (n.left != null) {
        dfs(n.left, s + n.val + &quot;-&gt;&quot;, output);
    }
    if (n.right != null) {
        dfs(n.right, s + n.val + &quot;-&gt;&quot;, output);
    }
}
</code></pre>
            <h3>Same Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * Any kind of traversal of tree (in-order, post-order, pre-order) will suffice.
 * If sub nodes do not be in same situation (null or not null), return false.
 * If value in tree node is same, continue recursion in sub nodes.
 *
 * @param p TreeNode 1
 * @param q TreeNode 2
 * @return if two trees are same
 */
public boolean isSameTree(TreeNode p, TreeNode q) {

    if (p == null &amp;&amp; q == null) {       // end point
        return true;
    }

    if (p == null || q == null) {       // if given two trees has different child node, return false
        return false;
    }
    if (p.val == q.val) {
        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);
    }
    return false;
}
</code></pre>
            <h3>Symmetric Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * Pre-order traversal.
 *
 * @param root root TreeNode
 * @return if this tree is symmetric
 */
public boolean isSymmetric(TreeNode root) {

    /* Corner case */
    if (root == null) {
        return true;
    }
    if (root.left == null &amp;&amp; root.right == null) {
        return true;
    }
    if (root.left == null || root.right == null) {
        return false;
    }

    if (root.left.val == root.right.val) {
        return isSymmetricTree(root.left, root.right);
    }

    return false;
}

/**
 * Almost same as IsSameTree_100 problem, only simply modified the recursion to compare left node and right node.
 *
 * @param p TreeNode 1
 * @param q TreeNode 2
 * @return if two trees are symmetric
 */
private boolean isSymmetricTree(TreeNode p, TreeNode q) {
    if (p == null &amp;&amp; q == null) {
        return true;
    }
    if (p == null || q == null) {
        return false;
    }
    if (p.val == q.val) {
        return isSymmetricTree(p.left, q.right) &amp;&amp; isSymmetricTree(p.right, q.left);
    }
    return false;
}
</code></pre>
            <h3>Maximum Depth of Binary Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS, using pre-order traversal.
 *
 * @param root root node
 * @return max depth.
 */
public int maxDepth(TreeNode root) {

    /* Corner case and end point */
    if (root == null) {
        return 0;
    }

    /* Keep find left sub tree and right sub tree until reaches the end */
    return Integer.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
</code></pre>
            <h3>Minimum Depth of Binary Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * In order traversal.
 *
 * @param root root node
 * @return depth
 */
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int l = minDepth(root.left);
    int r = minDepth(root.right);

    return (l == 0 || r == 0) ? l + r + 1 : Math.min(l, r) + 1;
}
</code></pre>
            <h3>Convert Sorted Array to Binary Search Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * Root of the tree is at the mid of array and sub array.
 *
 * @param nums given num array
 * @return height balanced BST
 */
public TreeNode sortedArrayToBST(int[] nums) {

    /* */
    if (nums.length &lt; 2) {
        return (nums.length == 0 ? null : new TreeNode(nums[0]));
    }

    return builder(nums, 0, nums.length - 1);
}

/**
 * Pre-order traversal.
 *
 * @param num   given num array
 * @param start start index
 * @param end   end index
 * @return root of height balanced BST
 */
private TreeNode builder(int[] num, int start, int end) {

    /* End point */
    if (start &gt; end) {
        return null;
    }

    int mid = (start + end) / 2;

    TreeNode root = new TreeNode(num[mid]);

    root.left = builder(num, start, mid - 1);
    root.right = builder(num, mid + 1, end);
    return root;
}
</code></pre>
            <h3>Convert Sorted List to Binary Search Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * Linked list can not directly get item by index.
 * Therefore, use two pointers to traverse the linked list
 * When faster one reaches the end of list, slow one will be at root (middle of linked list).
 *
 * @param head head node
 * @return root of height balanced BST
 */
public TreeNode sortedListToBST(ListNode head) {

    /* Corner case */
    if (head == null) {
        return null;
    }

    return builder(head, null);
}

/**
 * Use two pointer to find root node.
 * Fast node moves two time faster than slow node.
 * In this way, if fast node reaches the end, slow node will accurately at the mid of list, which is root.
 *
 * @param head head node
 * @param tail end node
 * @return root of height balanced BST
 */
public TreeNode builder(ListNode head, ListNode tail) {

    ListNode slow = head;       // find root (in the mid of linked list)
    ListNode fast = head;       // two time faster move speed

    if (head == tail) {
        return null;
    }

    while (fast != tail &amp;&amp; fast.next != tail) {
        fast = fast.next.next;      // when fast reaches the end, slow will be at mid of list
        slow = slow.next;           // stop at root
    }

    TreeNode root = new TreeNode(slow.val);
    root.left = builder(head, slow);
    root.right = builder(slow.next, tail);

    return root;
}
</code></pre>
            <h3>Balanced Binary Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS traversal.
 *
 * @param root root node
 * @return if given tree is height-balanced
 */
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }

    return dfs(root) != -1;
}

/**
 * DFS traversal. If current tree has a imbalanced tree, return -1.
 * Otherwise return the height difference.
 *
 * @param root root node
 * @return if given tree is height-balanced
 */
private int dfs(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int left = dfs(root.left);
    int right = dfs(root.right);

    if (left == -1 || right == -1 || Math.abs(left - right) &gt; 1) {      // left/right/current tree is not height-balanced
        return -1;      // sub tree is not height-balanced
    }

    return Math.max(left, right) + 1;       // depth + 1
}
</code></pre>
            <h3>Path Sum</h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS Tree traversal.
 *
 * @param root root node
 * @param sum  given sum
 * @return if it has a root-to-leaf path such that sum of all values along the path equals the given sum
 */
public boolean hasPathSum(TreeNode root, int sum) {

    if (root == null) {
        return false;
    }

    if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == root.val) {
        return true;
    }

    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
</code></pre>
            <h3>Path Sum II</h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS.
 *
 * @param root root tree node
 * @param sum  given sum
 * @return all root-to-leaf paths where each path&#39;s sum equals the given sum
 */
public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    if (root == null) {
        return res;
    }
    dfs(root, sum, res, new ArrayList&lt;&gt;());

    return res;
}


/**
 * Running DFS to find all possible path.
 *
 * @param r     current root node
 * @param sum   required sum
 * @param res   path list
 * @param cache temporary path list
 * @return all root-to-leaf paths sum equals the given sum
 */
private List&lt;List&lt;Integer&gt;&gt; dfs(TreeNode r, int sum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; cache) {

    cache.add(r.val);

    if (r.left == null &amp;&amp; r.right == null &amp;&amp; r.val == sum) {
        res.add(new ArrayList&lt;&gt;(cache));

    } else {
        if (r.left != null) {
            dfs(r.left, sum - r.val, res, cache);
        }
        if (r.right != null) {
            dfs(r.right, sum - r.val, res, cache);
        }
    }

    cache.remove(cache.size() - 1);

    return res;
}
</code></pre>
            <h3>Sum Root to Leaf Numbers</h3>
            <pre><code class='language-java' lang='java'>/**
 * DFS.
 *
 * @param root root node
 * @return total sum of all root-to-leaf numbers
 */
public int sumNumbers(TreeNode root) {
    return dfs(root, 0);
}

/**
 * Add each node&#39;s value with 10^n
 *
 * @param r root node
 * @param n power
 * @return total sum of all root-to-leaf numbers
 */
public int dfs(TreeNode r, int n) {

    /* End point */
    if (r == null) {
        return 0;
    }

    if (r.right == null &amp;&amp; r.left == null) {
        return n * 10 + r.val;
    }

    return dfs(r.left, n * 10 + r.val) + dfs(r.right, n * 10 + r.val);
}
</code></pre>
            <h3>Insert into a Binary Search Tree</h3>
            <pre><code class='language-java' lang='java'>/**
 * Insert new node to correct subtree of leaf.
 *
 * @param root root node
 * @param val  value to be insert
 * @return BST with inserted value
 */
public TreeNode insertIntoBST(TreeNode root, int val) {

    /* Corner case and end point */
    if (root == null) {
        return new TreeNode(val);
    }

    if (val &lt; root.val) {
        root.left = insertIntoBST(root.left, val);
    } else if (val &gt; root.val) {
        root.right = insertIntoBST(root.right, val);
    }
    return root;
}
</code></pre>
        </div>
    </div>
</section>
<!--        inner script to control nav bar        -->

<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>
</body>
</html>