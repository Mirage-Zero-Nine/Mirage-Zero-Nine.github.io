<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Populating Next Right Pointers in Each Node | Algorithm</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../../static/css/post-content.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
</head>
<body>

<!--        nav bar     -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>Populating Next Right Pointers in Each Node</h1>
        </div>

        <div class="text-right post-date">
            June 04, 2019
        </div>

        <div class="post-main">
            <p>Links: </p>
            <p><a href='https://leetcode.com/problems/populating-next-right-pointers-in-each-node'>Populating Next Right
                Pointers in Each Node</a></p>
            <p><a href='https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii'>Populating Next
                Right Pointers in Each Node II</a></p>
            <h2>Problem description</h2>
            <h3>Populating Next Right Pointers in Each Node</h3>
            <p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every
                parent has two children. The binary tree has the following definition:</p>
            <pre><code class='language-java' lang='java'>// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val,Node _left,Node _right,Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
</code></pre>
            <p>Populate each next pointer to point to its next right node. If there is no next right node, the next
                pointer should be set to <code>NULL</code>.</p>
            <p>Initially, all next pointers are set to <code>NULL</code>.</p>
            <p><strong>Example:</strong></p>
            <p><img src='../../static/img/116_sample.png' alt='img'
                    referrerPolicy='no-referrer' style="width: 100%;"/></p>
            <pre><code>Input: {&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}

Output: {&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:6},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;7&quot;},&quot;val&quot;:1}

Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.
</code></pre>
            <p><strong>Note:</strong></p>
            <ul>
                <li>You may only use constant extra space.</li>
                <li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.
                </li>

            </ul>
            <h3>Populating Next Right Pointers in Each Node II</h3>
            <p>Given a binary tree</p>
            <pre><code class='language-java' lang='java'>// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node next;

    public Node() {}

    public Node(int _val,Node _left,Node _right,Node _next) {
        val = _val;
        left = _left;
        right = _right;
        next = _next;
    }
};
</code></pre>
            <p>Populate each next pointer to point to its next right node. If there is no next right node, the next
                pointer should be set to <code>NULL</code>.</p>
            <p>Initially, all next pointers are set to <code>NULL</code>.</p>
            <p><strong>Example:</strong></p>
            <p><img src='../../static/img/117_sample.png' alt='img'
                    referrerPolicy='no-referrer' style="width: 100%;"/></p>
            <pre><code>Input: {&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;val&quot;:3},&quot;val&quot;:1}

Output: {&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:{&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:{&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7},&quot;right&quot;:null,&quot;val&quot;:5},&quot;right&quot;:null,&quot;val&quot;:4},&quot;next&quot;:{&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;5&quot;},&quot;val&quot;:3},&quot;right&quot;:{&quot;$ref&quot;:&quot;4&quot;},&quot;val&quot;:2},&quot;next&quot;:null,&quot;right&quot;:{&quot;$ref&quot;:&quot;6&quot;},&quot;val&quot;:1}

Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.
</code></pre>
            <p><strong>Note:</strong></p>
            <ul>
                <li>You may only use constant extra space.</li>
                <li>Recursive approach is fine, implicit stack space does not count as extra space for this problem.
                </li>

            </ul>
            <h2>Method</h2>
            <p>First problem is easy, store each level’s start node, next level (if exist) will start at current
                left-most node’s left child. The given tree is perfect binary tree, therefore, simply connect left child
                node to right child node, and right child node to next node’s left child. Leave last right child node
                alone, since it is supposed to connect to <code>Null</code> and default value is <code>Null</code>.</p>
            <p>Second problem is a little complicated, since the given tree is not perfect tree and there may exist
                empty node in same level. However, idea keeps the same. The first node will always be the root node,
                therefore, connect root’s non-empty child node will set the <code>next</code> pointer, and will keep the
                same in later iteration. Therefore, use a Node storing previous node and link to next node to skip empty
                nodes. What’s more, a node that store each level’s start node is still required. And that follows the
                rule of using only constant space.</p>
            <h2>Code</h2>
            <p><a href='https://leetcode.com/problems/populating-next-right-pointers-in-each-node'>Populating Next Right
                Pointers in Each Node</a></p>
            <pre><code class='language-java' lang='java'>/**
 * BFS.
 * It is a perfect binary tree. Hence, simply point next layer&#39;s sub node to its right node.
 * left sub node -&gt; right sub node
 * right sub node -&gt; next left sub node
 * If reach the end of current layer node, do nothing. The default next is null.
 *
 * @param root root node
 * @return populated tree
 */
public Node connect(Node root) {
    Node level = root;
    while (level != null) {
        Node cur = level;
        while (cur != null) {

            /* Link left and right sub node under same parent node */
            if (cur.left != null) {
                cur.left.next = cur.right;
            }

            /* Link right sub node to next parent node&#39;s left sub node */
            if (cur.right != null &amp;&amp; cur.next != null) {
                cur.right.next = cur.next.left;
            }
            cur = cur.next;     // next node
        }
        level = level.left;     // next layer
    }
    return root;
}
</code></pre>
            <p><a href='https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii'>Populating Next
                Right Pointers in Each Node II</a></p>
            <pre><code class='language-java' lang='java'>/**
 * BFS.
 * Use a Node to store previous node, link to next node.
 * Use a Node to store the next layer&#39;s head node for iteration.
 *
 * @param root root node
 * @return populate tree
 */
public Node connect(Node root) {
    Node nextHead = null;
    Node nextPrevious = null;
    Node current = root;

    /* Iterate whole tree */
    while (current != null) {

        /* Iterate current layer */
        while (current != null) {

            /* Left child */
            if (current.left != null) {
                if (nextPrevious != null) {
                    nextPrevious.next = current.left;
                } else {
                    nextHead = current.left;        // find new layer
                }
                nextPrevious = current.left;
            }

            /* Right child */
            if (current.right != null) {
                if (nextPrevious != null) {
                    nextPrevious.next = current.right;
                } else {
                    nextHead = current.right;       // find new layer
                }
                nextPrevious = current.right;
            }
            current = current.next;
        }
        current = nextHead;     // going to next layer
        nextHead = null;
        nextPrevious = null;
    }
    return root;
}
</code></pre>
        </div>
    </div>
</section>
<!--        inner script to control nav bar        -->

<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>
</body>
</html>