<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Problem Set - Combinations | Algorithm</title>
    <link rel="stylesheet" type="text/css"
          href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css?family=Martel+Sans:200,300,400,600,700,800,900&display=swap"
          rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Raleway:200i,400,800" rel="stylesheet">
    <link rel="stylesheet" href="../../static/css/post-content.css">
    <link rel="stylesheet" href="../../static/bootstrap-4.3.1-dist/css/bootstrap.css">

    <!--    title icon        -->
    <link rel="shortcut icon" type="image/x-icon" href="../../static/img/Avatar-3.jpg"/>
    <link rel="stylesheet" href="../../static/css/coding.css">
    <script src="../../static/script/coding_style.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <style> @media print {
        .hljs {
            overflow: visible;
            word-wrap: break-word !important;
        }
    }</style>
</head>
<body>

<!--        nav bar     -->
<nav id="mainNav" class="navbar navbar-expand-lg py-0 fixed-top">
    <div class="container">
        <a class="navbar-brand" href="https://yyzhou95.github.io/">HOME</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mr-auto">
                <li class="nav-item active">
                    <a class="nav-link" href="../index.html">Posts <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../tags/index.html">Tags <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../algorithm/index.html">Algorithm <span
                            class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item active">
                    <a class="nav-link" href="../../archived/index.html">Archived <span class="sr-only">(current)</span></a>
                </li>
                <li class="nav-item dropdown active">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-toggle="dropdown"
                       aria-haspopup="true" aria-expanded="false">
                        Other Links
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="https://github.com/yyzhou95">Github</a>
                        <a class="dropdown-item" href="https://github.com/yyzhou95/yyzhou95.github.io">This page</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="../../about/">About Me</a>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</nav>

<section class="post-content">
    <div class="container">

        <div class="post-heading">
            <h1>
                Problem Set - Combinations
            </h1>
        </div>

        <div class="text-right post-date">
            August 19, 2019
        </div>
        <div class="post-main">
            <p>Links: </p>
            <ul>
                <li><a href='https://leetcode.com/problems/combinations/'>Combinations</a></li>
                <li><a href='https://leetcode.com/problems/letter-combinations-of-a-phone-number/'>Letter Combinations
                    of a Phone Number</a></li>
                <li><a href='https://leetcode.com/problems/combination-sum/'>Combination Sum</a></li>
                <li><a href='https://leetcode.com/problems/combination-sum-ii/'>Combination Sum II</a></li>
                <li><a href='https://leetcode.com/problems/combination-sum-iii/'>Combination Sum III</a></li>
            </ul>
            <h2>Problem description </h2>
            <h3>Combinations</h3>
            <p>Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.</p>
            <p><strong>Example:</strong></p>
            <pre><code>Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</code></pre>
            <h3>Letter Combinations of a Phone Number</h3>
            <p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations
                that the number could represent.</p>
            <p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not
                map to any letters.</p>
            <p><strong>Example:</strong></p>
            <pre><code>Input: &quot;23&quot;
Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
</code></pre>
            <p><strong>Note:</strong></p>
            <ul>
                <li>Although the above answer is in lexicographical order, your answer could be in any order you want.
                </li>

            </ul>
            <h3>Combination Sum</h3>
            <p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all
                unique combinations in candidates where the candidate numbers sums to target.</p>
            <p>The same repeated number may be chosen from candidates unlimited number of times.</p>
            <p>Note:</p>
            <ol>
                <li>All numbers (including target) will be positive integers.</li>
                <li>The solution set must not contain duplicate combinations.</li>

            </ol>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre>
            <h3>Combination Sum II</h3>
            <p>Given a collection of candidate numbers (<code>candidates</code>) and a target number
                (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate
                numbers sums to <code>target</code>.</p>
            <p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p>
            <p><strong>Note:</strong></p>
            <ul>
                <li>All numbers (including <code>target</code>) will be positive integers.</li>
                <li>The solution set must not contain duplicate combinations.</li>

            </ul>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
</code></pre>
            <h3>Combination Sum III</h3>
            <p>Find all possible combinations of <strong><em>k</em></strong> numbers that add up to a number
                <strong><em>n</em></strong>, given that only numbers from 1 to 9 can be used and each combination should
                be a unique set of numbers.</p>
            <p><strong>Note:</strong></p>
            <ul>
                <li>All numbers will be positive integers.</li>
                <li>The solution set must not contain duplicate combinations.</li>

            </ul>
            <p><strong>Example 1:</strong></p>
            <pre><code>Input: k = 3, n = 7
Output: [[1,2,4]]
</code></pre>
            <p><strong>Example 2:</strong></p>
            <pre><code>Input: k = 3, n = 9
Output: [[1,2,6], [1,3,5], [2,3,4]]
</code></pre>
            <h2>Method</h2>
            <h3>Combinations</h3>
            <p>Two approaches. </p>
            <p>First approach is using backtracking. The other approach is to use the property of combination.</p>
            <p>Using combination based on recursion is faster, where <code>C(n, k) = C(n - 1, k - 1) + C(n - 1,
                k)</code>.</p>
            <h3>Letter Combinations of a Phone Number</h3>
            <p>Find all possible combination by backtracking. Note that <code>0</code> and <code>1</code> mapping to
                nothing.</p>
            <h3>Combination Sum I</h3>
            <p>Use backtracking to find all combinations via traversing all elements in candidate array each time.</p>
            <h3>Combination Sum II</h3>
            <p>Sort array first, then use backtracking to find all combinations via traversing all elements in candidate
                array.</p>
            <p>To avoid duplication, skip duplicated elements in backtracking by adding a boolean array.</p>
            <h3>Combination Sum III</h3>
            <p>Backtracking. The candidate array is from <code>0</code> to <code>n</code>.</p>
            <h2>Code</h2>
            <h3>Combinations</h3>
            <pre><code class='language-java' lang='java'>/**
 * Two approaches. First approach is using backtracking.
 * The other approach is to use the property of combination.
 * Using combination based on recursion is faster, where C(n, k) = C(n - 1, k - 1) + C(n - 1, k).
 *
 * @param n n numbers could be in combination, from 1 to n
 * @param k each combination length
 * @return list contains all combinations
 */
public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {

    List&lt;List&lt;Integer&gt;&gt; output = new LinkedList&lt;&gt;();

    /* Corner case */
    if (k == 0 || n &lt; k) {      // C(n, k), n must be equal or larger than k, and k should be larger then 0
        return output;          // also, recursion ends here
    }

    output = combine(n - 1, k - 1);     // C(n - 1, k - 1)

    if (output.isEmpty()) {
        output.add(new LinkedList&lt;&gt;());     // add combination list during recursion
    }

    for (List&lt;Integer&gt; list : output) {
        list.add(n);
    }

    output.addAll(combine(n - 1, k));       // the other part, C(n - 1, k)

    return output;
}
</code></pre>
            <h3>Letter Combinations of a Phone Number</h3>
            <pre><code class='language-java' lang='java'>/**
 * Backtracking.
 *
 * @param digits input digits
 * @return string array list that contains all possible combinations
 */
public List&lt;String&gt; letterCombinations(String digits) {
    List&lt;String&gt; output = new LinkedList&lt;&gt;();

    /* Corner case */
    if (digits.length() == 0) {
        return output;
    }
    for (int i = 0; i &lt; digits.length(); i++) {
        if (digits.charAt(i) - &#39;0&#39; &lt; 2) {
            return output;      // no possible letter combinations when &#39;1&#39; or &#39;0&#39; exists
        }
    }

    backtracking(digits, output, &quot;&quot;);
    return output;
}

/**
 * Recursively find all combinations of digit letters.
 *
 * @param digit   input digit
 * @param output  each step&#39;s result
 * @param current each step&#39;s combination string
 */
private void backtracking(String digit, List&lt;String&gt; output, String current) {
    String[] keymap = new String[]{&quot; &quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};
    if (digit.length() == current.length()) {
        output.add(current);
    } else {
        String letters = keymap[digit.charAt(current.length()) - &#39;0&#39;];

        for (int i = 0; i &lt; letters.length(); i++) {
            backtracking(digit, output, current + letters.charAt(i));
        }
    }
}
</code></pre>
            <h3>Combination Sum</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use backtracking to find all combinations via traversing all elements in candidate array.
 *
 * @param candidates input candidate numbers
 * @param target     target numbers
 * @return result int list
 */
public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {
    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();

    /* Corner case */
    if (candidates.length &lt; 1) {
        return res;
    }

    /* Sort array to avoid duplication and use backtracking to find all combinations */
    Arrays.sort(candidates);

    backtracking(res, new ArrayList&lt;&gt;(), candidates, target, 0);
    return res;
}

/**
 * Backtracking to find all combination that the sum is target.
 *
 * @param result     result array list
 * @param temp       temp array list, if combination is found it will be added to result
 * @param candidates input candidates
 * @param remain     current input int, compare to target to check whether current combination correct
 * @param start      start position in array for current traversal
 */
private void backtracking(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp, int[] candidates, int remain, int start) {

    if (remain == 0) {
        result.add(new ArrayList&lt;&gt;(temp));
    }
    if (remain &gt; -1) {       // if remain &lt; 0, then current int can not be the result

        /* Iter rest elements in array */
        for (int i = start; i &lt; candidates.length; i++) {
            temp.add(candidates[i]);
            backtracking(result, temp, candidates, remain - candidates[i], i);
            temp.remove(temp.size() - 1);      // if it is not a possible combination, remove and continue
        }
    }
}
</code></pre>
            <h3>Combination Sum II</h3>
            <pre><code class='language-java' lang='java'>/**
 * Use backtracking to find all combinations via traversing all elements in candidate array.
 *
 * @param candidates input candidate numbers
 * @param target     target numbers
 * @return result int list
 */
public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    if (candidates.length &lt; 1) {
        return res;
    }

    Arrays.sort(candidates);        // avoid duplication

    if (candidates[0] &gt; target) {       // if min value in array is larger than target, return empty list
        return res;
    }

    backtracking(res, new ArrayList&lt;&gt;(), candidates, target, 0);
    return res;
}

/**
 * Backtracking to find all combination that the sum is target.
 *
 * @param result     result array list
 * @param temp       temp array list, if combination is found it will be added to result
 * @param candidates input candidates
 * @param remain     current input int, compare to target to check whether current combination correct
 * @param start      start position in array for current traversal
 */
private void backtracking(List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp, int[] candidates, int remain, int start) {

    if (remain == 0) {
        result.add(new ArrayList&lt;&gt;(temp));      // end point
    }
    if (remain &gt; -1) {
        for (int i = start; i &lt; candidates.length; i++) {

            /* Remove duplicate elements in output */
            if (i == start || candidates[i] != candidates[i - 1]) {
                temp.add(candidates[i]);
                backtracking(result, temp, candidates, remain - candidates[i], i + 1);
                temp.remove(temp.size() - 1);
            }
        }
    }
}
</code></pre>
            <h3>Combination Sum III</h3>
            <pre><code class='language-java' lang='java'>/**
 * Backtracking.
 *
 * @param k size of each combination
 * @param n target sum of each combination
 * @return all possible combinations of k numbers that sum is n
 */
public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {
    List&lt;List&lt;Integer&gt;&gt; output = new ArrayList&lt;&gt;();
    if (k &lt; 1 || n &lt; 1) {
        return output;
    }

    backtracking(1, k, n, output, new ArrayList&lt;&gt;());

    return output;
}

/**
 * Backtracking. Note that i can be only from 1 to 9.
 * If the temp list size is not matched to given condition, it should not be added to result.
 *
 * @param current start position in array from 1 to 9
 * @param k       size of each combination
 * @param n       target sum
 * @param output  output list
 * @param temp    temp list
 */
private void backtracking(int current, int k, int n, List&lt;List&lt;Integer&gt;&gt; output, List&lt;Integer&gt; temp) {
    if (temp.size() == k &amp;&amp; n == 0) {
        output.add(new ArrayList&lt;&gt;(temp));      // end point
    } else {
        for (int i = current; i &lt; 10; i++) {
            temp.add(i);
            backtracking(i + 1, k, n - i, output, temp);
            temp.remove(temp.size() - 1);
        }
    }
}
</code></pre>
        </div>
    </div>
</section>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
<!--        This order must be followed!!       -->
<script src="../../static/jquery/jquery-3.3.1.js"></script>
<script src="../../static/popper/popper.js"></script>
<script src="../../static/bootstrap-4.3.1-dist/js/bootstrap.js"></script>

<!-- Nav bar control -->
<script src="../../static/script/nav-bar.js"></script>
</body>
</html>